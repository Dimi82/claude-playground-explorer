<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brainstorm Explorer</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    :root {
      --bg: #1a1a2e; --surface: #16213e; --surface-alt: #1f2b47; --border: #2d3a5a;
      --text: #e8e8e8; --text-dim: #8892a8; --accent: #4fc3f7; --accent-dim: #2a7a9e;
      --know: #4caf50; --fuzzy: #ff9800; --unknown: #f44336; --explore: #9c27b0;
    }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; background: var(--bg); color: var(--text); height: 100vh; overflow: hidden; }
    .container { display: grid; grid-template-columns: 280px 1fr 320px; grid-template-rows: auto 1fr; height: 100vh; gap: 1px; background: var(--border); }
    header { grid-column: 1 / -1; background: var(--surface); padding: 12px 20px; display: flex; align-items: center; justify-content: space-between; }
    header h1 { font-size: 16px; font-weight: 600; color: var(--accent); }
    .presets { display: flex; gap: 8px; }
    .preset-btn { background: var(--surface-alt); border: 1px solid var(--border); color: var(--text-dim); padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 12px; transition: all 0.2s; }
    .preset-btn:hover { background: var(--border); color: var(--text); }
    .preset-btn.active { background: var(--accent-dim); border-color: var(--accent); color: var(--text); }
    .sidebar { background: var(--surface); padding: 16px; overflow-y: auto; }
    .sidebar h2 { font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-dim); margin-bottom: 12px; }
    .topic-group { margin-bottom: 20px; }
    .topic-header { display: flex; align-items: center; gap: 8px; padding: 8px; background: var(--surface-alt); border-radius: 6px; margin-bottom: 8px; cursor: pointer; }
    .topic-header:hover { background: var(--border); }
    .topic-dot { width: 10px; height: 10px; border-radius: 50%; }
    .topic-header span { font-size: 13px; font-weight: 500; }
    .concept-list { padding-left: 18px; }
    .concept-item { display: flex; align-items: center; gap: 8px; padding: 6px 8px; border-radius: 4px; cursor: pointer; font-size: 12px; color: var(--text-dim); transition: all 0.15s; }
    .concept-item:hover { background: var(--surface-alt); color: var(--text); }
    .concept-item.selected { background: var(--accent-dim); color: var(--text); }
    .status-badge { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
    .status-know { background: var(--know); }
    .status-fuzzy { background: var(--fuzzy); }
    .status-unknown { background: var(--unknown); }
    .status-explore { background: var(--explore); }
    .canvas-container { background: var(--bg); position: relative; overflow: hidden; cursor: default; }
    .canvas-container.edge-mode { cursor: crosshair; }
    #canvas { width: 100%; height: 100%; }
    .tooltip { position: absolute; background: var(--surface); border: 1px solid var(--border); padding: 10px 14px; border-radius: 6px; font-size: 12px; max-width: 280px; pointer-events: none; opacity: 0; transition: opacity 0.15s; z-index: 100; box-shadow: 0 4px 20px rgba(0,0,0,0.4); }
    .tooltip.visible { opacity: 1; }
    .tooltip-title { font-weight: 600; margin-bottom: 4px; color: var(--accent); }
    .tooltip-desc { color: var(--text-dim); line-height: 1.4; }
    .right-panel { background: var(--surface); display: flex; flex-direction: column; overflow-y: auto; }
    .panel-section { padding: 16px; border-bottom: 1px solid var(--border); }
    .panel-section:last-child { border-bottom: none; flex: 1; display: flex; flex-direction: column; }
    .panel-section h3 { font-size: 11px; text-transform: uppercase; letter-spacing: 0.5px; color: var(--text-dim); margin-bottom: 12px; }
    .legend { display: flex; flex-wrap: wrap; gap: 12px; }
    .legend-item { display: flex; align-items: center; gap: 6px; font-size: 11px; color: var(--text-dim); cursor: pointer; padding: 4px 8px; border-radius: 4px; transition: all 0.15s; }
    .legend-item:hover { background: var(--surface-alt); }
    .legend-item.active { background: var(--surface-alt); color: var(--text); }
    .ideas-container { flex: 1; overflow-y: auto; margin-bottom: 12px; }
    .idea-card { background: var(--surface-alt); border: 1px solid var(--border); border-radius: 6px; padding: 12px; margin-bottom: 8px; cursor: pointer; transition: all 0.15s; }
    .idea-card:hover { border-color: var(--accent-dim); }
    .idea-card.selected { border-color: var(--accent); background: var(--accent-dim); }
    .idea-card h4 { font-size: 13px; font-weight: 500; margin-bottom: 4px; }
    .idea-card p { font-size: 11px; color: var(--text-dim); line-height: 1.4; }
    .idea-card .topic-tag { display: inline-block; font-size: 10px; padding: 2px 6px; border-radius: 3px; margin-top: 8px; }
    .idea-card-header { display: flex; justify-content: space-between; align-items: flex-start; gap: 8px; }
    .idea-card-header h4 { flex: 1; margin: 0; }
    .delete-idea-btn { background: transparent; border: none; color: var(--text-dim); cursor: pointer; font-size: 14px; padding: 2px 6px; border-radius: 4px; line-height: 1; transition: all 0.15s; }
    .delete-idea-btn:hover { background: var(--unknown); color: var(--text); }
    .add-idea-btn { width: 100%; background: transparent; border: 1px dashed var(--border); color: var(--text-dim); padding: 10px; border-radius: 6px; cursor: pointer; font-size: 12px; transition: all 0.15s; }
    .add-idea-btn:hover { border-color: var(--accent-dim); color: var(--text); }
    .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; pointer-events: none; transition: opacity 0.2s; }
    .modal-overlay.visible { opacity: 1; pointer-events: auto; }
    .modal { background: var(--surface); border: 1px solid var(--border); border-radius: 8px; padding: 24px; width: 400px; max-width: 90vw; }
    .modal h3 { font-size: 16px; margin-bottom: 16px; }
    .modal input, .modal textarea, .modal select { width: 100%; background: var(--bg); border: 1px solid var(--border); color: var(--text); padding: 10px; border-radius: 4px; font-size: 13px; margin-bottom: 12px; }
    .modal textarea { min-height: 80px; resize: vertical; font-family: inherit; }
    .modal-actions { display: flex; gap: 8px; justify-content: flex-end; margin-top: 8px; }
    .modal-btn { padding: 8px 16px; border-radius: 4px; font-size: 13px; cursor: pointer; border: 1px solid var(--border); }
    .modal-btn.primary { background: var(--accent); border-color: var(--accent); color: var(--bg); }
    .modal-btn.secondary { background: transparent; color: var(--text-dim); }
    .instructions { background: var(--surface-alt); border-radius: 6px; padding: 12px; margin-bottom: 16px; font-size: 11px; color: var(--text-dim); line-height: 1.5; }
    .instructions strong { color: var(--text); }
    .edge-controls { display: flex; gap: 8px; margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border); }
    .edge-mode-btn { flex: 1; background: var(--surface-alt); border: 1px solid var(--border); color: var(--text-dim); padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 11px; transition: all 0.15s; }
    .edge-mode-btn:hover { background: var(--border); color: var(--text); }
    .edge-mode-btn.active { background: var(--accent-dim); border-color: var(--accent); color: var(--text); }
    .edge-mode-indicator { position: absolute; top: 10px; left: 10px; background: var(--accent); color: var(--bg); padding: 6px 12px; border-radius: 4px; font-size: 11px; font-weight: 600; z-index: 50; display: none; }
    .edge-mode-indicator.visible { display: block; }
    /* Zoom Controls */
    .zoom-controls {
      position: absolute; bottom: 16px; right: 16px; display: flex; gap: 4px;
      background: var(--surface); border: 1px solid var(--border); border-radius: 8px;
      padding: 8px; z-index: 100; box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    .zoom-btn {
      background: var(--surface-alt); border: 1px solid var(--border); border-radius: 4px;
      color: var(--text); width: 32px; height: 32px; cursor: pointer; font-size: 16px;
      display: flex; align-items: center; justify-content: center; transition: all 0.15s;
    }
    .zoom-btn:hover { background: var(--border); }
    .zoom-btn:active { transform: scale(0.95); }
    .zoom-btn.zoom-text { width: auto; padding: 0 10px; font-size: 11px; }
    .zoom-level {
      color: var(--text-dim); font-size: 11px; display: flex; align-items: center;
      padding: 0 8px; min-width: 45px; justify-content: center;
    }

    /* ========== AI Bridge Integration ========== */
    .bridge-status {
      position: fixed; top: 12px; left: 50%; transform: translateX(-50%); display: flex; align-items: center;
      gap: 6px; padding: 6px 12px; border-radius: 6px; font-size: 11px;
      background: var(--surface); border: 1px solid var(--border); z-index: 200;
    }
    .bridge-status .status-dot {
      width: 8px; height: 8px; border-radius: 50%; transition: background 0.3s;
    }
    .bridge-status.connected .status-dot { background: var(--know); }
    .bridge-status.disconnected .status-dot { background: var(--unknown); }
    .bridge-status.connecting .status-dot { background: var(--fuzzy); animation: pulse 1s infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

    .ai-context-menu {
      position: absolute; background: var(--surface); border: 1px solid var(--border);
      border-radius: 8px; padding: 8px; z-index: 300; min-width: 180px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4); display: none;
    }
    .ai-context-menu.visible { display: block; }
    .ai-context-item {
      display: flex; align-items: center; gap: 10px; padding: 8px 12px;
      border-radius: 6px; cursor: pointer; font-size: 12px; transition: background 0.15s;
    }
    .ai-context-item:hover { background: var(--surface-alt); }
    .ai-context-item .icon { font-size: 14px; }
    .ai-context-item.disabled { opacity: 0.5; cursor: not-allowed; }
    .ai-context-item.divider {
      height: 1px; background: var(--border); margin: 4px 0; padding: 0;
    }

    .node-ai-loading {
      position: absolute; background: rgba(26, 26, 46, 0.9);
      border-radius: 50%; display: flex; flex-direction: column;
      align-items: center; justify-content: center; z-index: 50;
    }
    .node-ai-loading .spinner {
      width: 16px; height: 16px; border: 2px solid var(--border);
      border-top-color: var(--accent); border-radius: 50%; animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* AI Response Panel */
    .ai-response-panel {
      position: fixed; bottom: 140px; right: 20px; width: 350px; max-height: 400px;
      background: var(--surface); border: 1px solid var(--border); border-radius: 8px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4); z-index: 250; display: none;
      flex-direction: column;
    }
    .ai-response-panel.visible { display: flex; }
    .ai-response-header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 12px 16px; border-bottom: 1px solid var(--border);
    }
    .ai-response-header h4 { font-size: 13px; font-weight: 600; margin: 0; color: var(--accent); }
    .ai-response-close {
      background: transparent; border: none; color: var(--text-dim);
      font-size: 18px; cursor: pointer; padding: 0; line-height: 1;
    }
    .ai-response-close:hover { color: var(--text); }
    .ai-response-content {
      padding: 16px; overflow-y: auto; flex: 1; font-size: 13px;
      line-height: 1.5; color: var(--text);
    }

    /* ========== Markdown Rendering Styles ========== */
    .markdown h2 { font-size: 14px; font-weight: 600; margin: 12px 0 8px; color: var(--accent); border-bottom: 1px solid var(--border); padding-bottom: 4px; }
    .markdown h3 { font-size: 13px; font-weight: 600; margin: 10px 0 6px; color: var(--text); }
    .markdown h4 { font-size: 12px; font-weight: 600; margin: 8px 0 4px; color: var(--text-dim); }
    .markdown p { margin: 6px 0; }
    .markdown ul, .markdown ol { margin: 6px 0; padding-left: 20px; }
    .markdown li { margin: 3px 0; }
    .markdown code { background: var(--bg); padding: 2px 6px; border-radius: 4px; font-family: 'SF Mono', Monaco, monospace; font-size: 11px; color: var(--fuzzy); }
    .markdown pre { background: var(--bg); border: 1px solid var(--border); border-radius: 6px; padding: 12px; margin: 8px 0; overflow-x: auto; }
    .markdown pre code { background: none; padding: 0; color: var(--text); display: block; white-space: pre; }
    .markdown strong { color: var(--text); font-weight: 600; }
    .markdown em { font-style: italic; color: var(--text-dim); }
    .markdown table { border-collapse: collapse; width: 100%; margin: 8px 0; font-size: 12px; }
    .markdown th, .markdown td { border: 1px solid var(--border); padding: 6px 10px; text-align: left; }
    .markdown th { background: var(--surface-alt); font-weight: 600; }

    /* ========== Annotation History Styles ========== */
    .concept-item.has-annotation::after { content: '‚óè'; color: var(--explore); margin-left: 6px; font-size: 8px; }
    .annotations-history { padding: 16px; overflow-y: auto; flex: 1; }
    .annotation-item { background: var(--surface-alt); border: 1px solid var(--border); border-radius: 6px; padding: 12px; margin-bottom: 12px; }
    .annotation-item.ai-annotation { border-left: 3px solid var(--explore); }
    .annotation-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
    .annotation-type { font-size: 10px; font-weight: 600; text-transform: uppercase; color: var(--explore); padding: 2px 8px; background: rgba(156, 39, 176, 0.2); border-radius: 10px; }
    .annotation-time { font-size: 10px; color: var(--text-dim); }
    .annotation-delete { background: transparent; border: none; color: var(--text-dim); cursor: pointer; font-size: 16px; padding: 2px 6px; border-radius: 4px; line-height: 1; }
    .annotation-delete:hover { background: var(--unknown); color: var(--text); }
    .annotation-text { font-size: 12px; line-height: 1.5; color: var(--text); }
    .annotation-collapsed { max-height: 150px; overflow: hidden; position: relative; }
    .annotation-collapsed::after { content: ''; position: absolute; bottom: 0; left: 0; right: 0; height: 40px; background: linear-gradient(transparent, var(--surface-alt)); pointer-events: none; }
    .annotation-expand-btn { background: transparent; border: 1px dashed var(--border); color: var(--text-dim); padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 11px; width: 100%; margin-top: 8px; }
    .annotation-expand-btn:hover { border-color: var(--accent); color: var(--text); }
    .history-header { display: flex; justify-content: space-between; align-items: flex-start; padding: 16px; border-bottom: 1px solid var(--border); position: relative; }
    .history-header h3 { font-size: 14px; font-weight: 600; margin: 0; color: var(--text); }
    .history-subtitle { font-size: 11px; color: var(--text-dim); margin-top: 4px; }
    .close-history-btn { background: transparent; border: none; color: var(--text-dim); font-size: 20px; cursor: pointer; padding: 0; line-height: 1; }
    .close-history-btn:hover { color: var(--text); }
    .empty-history { color: var(--text-dim); font-size: 12px; padding: 20px; text-align: center; }
    .history-header-actions { display: flex; gap: 8px; align-items: center; }
    .view-ideas-btn { background: var(--surface-alt); border: 1px solid var(--border); color: var(--text-dim); padding: 4px 10px; border-radius: 4px; cursor: pointer; font-size: 11px; }
    .view-ideas-btn:hover { background: var(--border); color: var(--text); }
    .annotation-type.question { background: rgba(79, 195, 247, 0.2); color: var(--accent); }
    .annotation-type.comment { background: rgba(76, 175, 80, 0.2); color: var(--know); }
    .annotation-type.edit { background: rgba(255, 152, 0, 0.2); color: var(--fuzzy); }
  </style>
</head>
<body>
  <!-- AI Bridge Status Indicator -->
  <div id="bridge-status" class="bridge-status disconnected">
    <span class="status-dot"></span>
    <span class="status-text">AI Disconnected</span>
  </div>

  <!-- AI Context Menu (positioned on right-click) -->
  <div id="ai-context-menu" class="ai-context-menu">
    <div class="ai-context-item" data-action="expand"><span class="icon">üí°</span> Expand idea</div>
    <div class="ai-context-item" data-action="challenge"><span class="icon">üéØ</span> Challenge</div>
    <div class="ai-context-item" data-action="connect"><span class="icon">üîó</span> Find connections</div>
    <div class="ai-context-item" data-action="clarify"><span class="icon">‚ùì</span> Clarify</div>
    <div class="ai-context-item" data-action="alternatives"><span class="icon">üîÑ</span> Alternatives</div>
    <div class="ai-context-item divider"></div>
    <div class="ai-context-item" data-action="add-question"><span class="icon">?</span> Add Question</div>
    <div class="ai-context-item" data-action="add-comment"><span class="icon">üìù</span> Add Comment</div>
    <div class="ai-context-item" data-action="mark-edit"><span class="icon">‚úèÔ∏è</span> Mark for Edit</div>
    <div class="ai-context-item divider"></div>
    <div class="ai-context-item" data-action="modify-graph"><span class="icon">üîÄ</span> AI: Modify Graph</div>
  </div>

  <!-- AI Response Panel -->
  <div id="ai-response-panel" class="ai-response-panel">
    <div class="ai-response-header">
      <h4 id="ai-response-title">AI Response</h4>
      <button class="ai-response-close" id="ai-response-close">&times;</button>
    </div>
    <div class="ai-response-content" id="ai-response-content"></div>
  </div>

  <div class="container">
    <header>
      <h1 id="header-title">Brainstorm Explorer</h1>
      <div class="presets" id="presets-container">
        <button class="preset-btn" id="export-btn" style="background: #238636;">Export Findings</button>
        <button class="preset-btn active" data-preset="all">All Topics</button>
      </div>
    </header>
    <div class="sidebar">
      <div class="instructions">
        <strong>How to use:</strong> Click concepts to cycle their status (Know -> Fuzzy -> Unknown -> Explore). Drag nodes on the canvas. Click "Add Idea" to capture new thoughts.
        <div class="edge-controls">
          <button class="edge-mode-btn" id="edge-mode-btn">Connect Nodes</button>
          <button class="edge-mode-btn" id="delete-edge-btn">Delete Edge</button>
        </div>
        <div class="edge-controls">
          <button class="edge-mode-btn" id="reset-btn" style="color: var(--unknown);">Reset All</button>
        </div>
      </div>
      <h2>Topics & Concepts</h2>
      <div id="concept-groups"></div>
    </div>
    <div class="canvas-container" id="canvas-container">
      <canvas id="canvas"></canvas>
      <div class="edge-mode-indicator" id="edge-indicator">Click source node...</div>
      <div class="tooltip" id="tooltip">
        <div class="tooltip-title"></div>
        <div class="tooltip-desc"></div>
      </div>
      <div class="zoom-controls">
        <button class="zoom-btn" id="zoom-out" title="Zoom Out (Ctrl+-)">‚àí</button>
        <div class="zoom-level" id="zoom-level">100%</div>
        <button class="zoom-btn" id="zoom-in" title="Zoom In (Ctrl++)">+</button>
        <button class="zoom-btn zoom-text" id="zoom-reset" title="Reset to 100% (Ctrl+0)">Reset</button>
        <button class="zoom-btn zoom-text" id="zoom-fit" title="Fit to View">Fit</button>
      </div>
    </div>
    <div class="right-panel">
      <div class="panel-section">
        <h3>Status Legend (click to filter)</h3>
        <div class="legend">
          <div class="legend-item active" data-status="all"><div class="status-badge" style="background: var(--text-dim)"></div>All</div>
          <div class="legend-item" data-status="know"><div class="status-badge status-know"></div>Know</div>
          <div class="legend-item" data-status="fuzzy"><div class="status-badge status-fuzzy"></div>Fuzzy</div>
          <div class="legend-item" data-status="unknown"><div class="status-badge status-unknown"></div>Unknown</div>
          <div class="legend-item" data-status="explore"><div class="status-badge status-explore"></div>Explore</div>
        </div>
      </div>
      <div class="panel-section">
        <h3>Captured Ideas</h3>
        <div class="ideas-container" id="ideas-container"></div>
        <button class="add-idea-btn" id="add-idea-btn">+ Add Idea</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="idea-modal">
    <div class="modal">
      <h3>Capture New Idea</h3>
      <input type="text" id="idea-title" placeholder="Idea title...">
      <textarea id="idea-desc" placeholder="Describe the idea, question, or insight..."></textarea>
      <select id="idea-topic"></select>
      <div class="modal-actions">
        <button class="modal-btn secondary" id="cancel-idea">Cancel</button>
        <button class="modal-btn primary" id="save-idea">Save Idea</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="question-modal">
    <div class="modal">
      <h3 id="question-modal-title">Ask about concept</h3>
      <textarea id="question-text" placeholder="Type your question to move the brainstorm forward..."></textarea>
      <div class="modal-actions">
        <button class="modal-btn secondary" id="cancel-question">Cancel</button>
        <button class="modal-btn primary" id="send-question">Ask AI</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="annotation-modal">
    <div class="modal">
      <h3 id="annotation-modal-title">Add Annotation</h3>
      <select id="annotation-type-select">
        <option value="question">Question</option>
        <option value="comment">Comment</option>
        <option value="edit">Mark for Edit</option>
      </select>
      <textarea id="annotation-text" placeholder="Add your note..."></textarea>
      <div class="modal-actions">
        <button class="modal-btn secondary" id="cancel-annotation">Cancel</button>
        <button class="modal-btn primary" id="save-annotation">Save</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="graph-modify-modal">
    <div class="modal">
      <h3 id="graph-modify-title">AI: Modify Graph</h3>
      <p style="font-size: 12px; color: var(--text-dim); margin-bottom: 12px;">Describe what changes you'd like the AI to make to the graph structure around this concept.</p>
      <textarea id="graph-modify-text" placeholder="Example: Add related security concepts, Connect this to authentication flow, Remove outdated nodes..."></textarea>
      <div class="modal-actions">
        <button class="modal-btn secondary" id="cancel-graph-modify">Cancel</button>
        <button class="modal-btn primary" id="send-graph-modify">Generate Changes</button>
      </div>
    </div>
  </div>

  <!-- External config: include before main script -->
  <!-- Example: <script src="config-myproject.js"></script> -->
  <!-- The config.js file should define: window.EXTERNAL_CONFIG = { projectName: "...", ... }; -->

  <!-- Sample config for testing (remove in production) -->
  <script src="sample-config.js" onerror="console.log('No sample-config.js found, expecting external config')"></script>

  <!-- Bridge Client for AI Connectivity (inlined for self-contained templates) -->
  <script>
(function() {
  'use strict';

  const BridgeClient = {
    baseUrl: 'http://localhost:4242',
    _connected: false,
    _onStatusChange: null,

    async checkConnection() {
      try {
        const response = await fetch(this.baseUrl + '/status');
        const ok = response.ok;
        this._setConnected(ok);
        return ok;
      } catch (e) {
        this._setConnected(false);
        return false;
      }
    },

    /**
     * Send action and wait for Claude's response.
     * The server holds the connection until Claude responds.
     */
    async sendAndWait(action, nodeId, graphType, context) {
      const response = await fetch(this.baseUrl + '/prompt', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action, nodeId, graphType, context })
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Request failed');
      }

      return response.json();
    },

    _setConnected(connected) {
      const changed = this._connected !== connected;
      this._connected = connected;
      if (changed && this._onStatusChange) {
        this._onStatusChange(connected);
      }
    },

    onStatusChange(callback) {
      this._onStatusChange = callback;
    },

    isConnected() {
      return this._connected;
    },

    startConnectionMonitor(interval = 10000) {
      this.checkConnection();
      setInterval(() => this.checkConnection(), interval);
    }
  };

  // AI prompt generator
  function generateAIPrompt(action, graphType, context) {
    const { nodeTitle, nodeDescription, projectName, file } = context;

    if (graphType === 'architecture') {
      switch (action) {
        case 'explain':
          return `Explain what ${nodeTitle} does.${file ? ' File: ' + file : ''}${nodeDescription ? '\n' + nodeDescription : ''}\nProject: ${projectName}`;
        case 'dependencies':
          return `What are the dependencies of ${nodeTitle}?${file ? ' File: ' + file : ''}\nProject: ${projectName}`;
        case 'improve':
          return `Suggest improvements for ${nodeTitle}.${file ? ' File: ' + file : ''}\nProject: ${projectName}`;
        case 'security':
          return `Security concerns for ${nodeTitle}?${file ? ' File: ' + file : ''}\nProject: ${projectName}`;
      }
    }
    return `Analyze "${nodeTitle}" in ${projectName}.`;
  }

  window.BridgeClient = BridgeClient;
  window.generateAIPrompt = generateAIPrompt;
})();
  </script>

  <script>
    // ============ CONFIGURATION LOADER ============
    (function init() {
      // Load config: prefer external window.EXTERNAL_CONFIG, fall back to inline
      function loadConfig() {
        // Check for externally loaded config (via <script src="config.js">)
        if (window.EXTERNAL_CONFIG) {
          return window.EXTERNAL_CONFIG;
        }

        // No external config found - show error
        alert('No configuration found. Either:\n1. Include a config script: <script src="config-name.js">\n2. Replace {{CONFIG_JSON}} with inline config');
        throw new Error('No configuration found');
      }

      const CONFIG = loadConfig();
    // ============ END CONFIGURATION LOADER ============

    const COLORS = CONFIG.colors;
    const TOPIC_NAMES = CONFIG.topicNames;
    const PROJECT_NAME = CONFIG.projectName;
    const INITIAL_CONCEPTS = CONFIG.concepts;
    const INITIAL_EDGES = CONFIG.edges;

    const STATUS_COLORS = { know: '#4caf50', fuzzy: '#ff9800', unknown: '#f44336', explore: '#9c27b0' };
    const STORAGE_KEY = 'brainstorm-explorer-' + PROJECT_NAME.toLowerCase().replace(/\s+/g, '-');

    const state = { concepts: INITIAL_CONCEPTS, edges: INITIAL_EDGES, ideas: [], annotations: {}, filter: 'all', activePreset: 'all', selectedConcept: null, dragging: null, dragOffset: { x: 0, y: 0 }, edgeMode: false, edgeSource: null, deleteEdgeMode: false, pendingAIRequests: {}, contextTarget: null };

    // ============ ZOOM MANAGEMENT ============
    const zoom = {
      scale: 1.0,
      minScale: 0.25,
      maxScale: 2.0,
      step: 0.1,
      offsetX: 0,
      offsetY: 0,

      updateDisplay: function() {
        const levelDisplay = document.getElementById('zoom-level');
        if (levelDisplay) {
          levelDisplay.textContent = Math.round(this.scale * 100) + '%';
        }
      },

      zoomIn: function() {
        this.scale = Math.min(this.maxScale, Math.round((this.scale + this.step) * 100) / 100);
        this.updateDisplay();
        this.save();
        draw();
      },

      zoomOut: function() {
        this.scale = Math.max(this.minScale, Math.round((this.scale - this.step) * 100) / 100);
        this.updateDisplay();
        this.save();
        draw();
      },

      reset: function() {
        this.scale = 1.0;
        this.offsetX = 0;
        this.offsetY = 0;
        this.updateDisplay();
        this.save();
        draw();
      },

      fitToView: function() {
        const visible = state.concepts.filter(c => isVisible(c));
        if (visible.length === 0) return;

        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        visible.forEach(c => {
          minX = Math.min(minX, c.x);
          minY = Math.min(minY, c.y);
          maxX = Math.max(maxX, c.x);
          maxY = Math.max(maxY, c.y);
        });

        const padding = 100;
        const contentWidth = maxX - minX + padding * 2;
        const contentHeight = maxY - minY + padding * 2;
        const canvasWidth = canvas.clientWidth;
        const canvasHeight = canvas.clientHeight;

        const scaleX = canvasWidth / contentWidth;
        const scaleY = canvasHeight / contentHeight;
        this.scale = Math.min(Math.max(Math.min(scaleX, scaleY), this.minScale), this.maxScale);
        this.scale = Math.round(this.scale * 100) / 100;

        // Center the content
        const centerX = (minX + maxX) / 2;
        const centerY = (minY + maxY) / 2;
        this.offsetX = canvasWidth / (2 * this.scale) - centerX;
        this.offsetY = canvasHeight / (2 * this.scale) - centerY;

        this.updateDisplay();
        this.save();
        draw();
      },

      zoomToPoint: function(delta, clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = clientX - rect.left;
        const mouseY = clientY - rect.top;

        // Convert mouse position to world coordinates before zoom
        const worldX = mouseX / this.scale - this.offsetX;
        const worldY = mouseY / this.scale - this.offsetY;

        const oldScale = this.scale;
        const zoomDelta = delta > 0 ? -this.step : this.step;
        this.scale = Math.max(this.minScale, Math.min(this.maxScale, Math.round((this.scale + zoomDelta) * 100) / 100));

        if (this.scale !== oldScale) {
          // Adjust offset to keep mouse position fixed in world coordinates
          this.offsetX = mouseX / this.scale - worldX;
          this.offsetY = mouseY / this.scale - worldY;

          this.updateDisplay();
          this.save();
          draw();
        }
      },

      screenToWorld: function(screenX, screenY) {
        return {
          x: screenX / this.scale - this.offsetX,
          y: screenY / this.scale - this.offsetY
        };
      },

      save: function() {
        try {
          localStorage.setItem(STORAGE_KEY + '-zoom', JSON.stringify({
            scale: this.scale,
            offsetX: this.offsetX,
            offsetY: this.offsetY
          }));
        } catch (e) { console.warn('Failed to save zoom:', e); }
      },

      load: function() {
        try {
          const saved = localStorage.getItem(STORAGE_KEY + '-zoom');
          if (saved) {
            const data = JSON.parse(saved);
            if (data.scale >= this.minScale && data.scale <= this.maxScale) {
              this.scale = data.scale;
              this.offsetX = data.offsetX || 0;
              this.offsetY = data.offsetY || 0;
              this.updateDisplay();
            }
          }
        } catch (e) { console.warn('Failed to load zoom:', e); }
      }
    };
    // ============ END ZOOM MANAGEMENT ============

    // ============ LIGHTWEIGHT MARKDOWN PARSER ============
    function parseMarkdown(text) {
      if (!text) return '';

      try {
        // Limit text length to prevent performance issues
        if (text.length > 50000) {
          text = text.substring(0, 50000) + '\n\n[Content truncated]';
        }

        // Escape HTML to prevent XSS
        var escaped = text
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');

      // Process code blocks first (```...```)
      escaped = escaped.replace(/```(\w*)\n([\s\S]*?)```/g, function(match, lang, code) {
        return '<pre><code>' + code.trim() + '</code></pre>';
      });

      // Process inline code (`...`)
      escaped = escaped.replace(/`([^`]+)`/g, '<code>$1</code>');

      // Process headers (## and ###)
      escaped = escaped.replace(/^#### (.+)$/gm, '<h4>$1</h4>');
      escaped = escaped.replace(/^### (.+)$/gm, '<h3>$1</h3>');
      escaped = escaped.replace(/^## (.+)$/gm, '<h2>$1</h2>');

      // Process bold (**text**)
      escaped = escaped.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');

      // Process italic (*text*)
      escaped = escaped.replace(/\*([^*]+)\*/g, '<em>$1</em>');

      // Process tables (| col1 | col2 |)
      escaped = escaped.replace(/^\|(.+)\|$/gm, function(match, content) {
        var cells = content.split('|').map(function(c) { return c.trim(); });
        return '<tr>' + cells.map(function(c) {
          if (c.match(/^-+$/)) return '';
          return '<td>' + c + '</td>';
        }).join('') + '</tr>';
      });
      escaped = escaped.replace(/(<tr>.*<\/tr>\n?)+/g, function(match) {
        if (match.includes('<td></td>')) {
          // This is a header separator row, convert first row to th
          var rows = match.split('</tr>').filter(function(r) { return r.trim(); });
          if (rows.length > 1) {
            rows[0] = rows[0].replace(/<td>/g, '<th>').replace(/<\/td>/g, '</th>');
            rows = rows.filter(function(r) { return !r.includes('<td></td>'); });
            return '<table>' + rows.join('</tr>') + '</tr></table>';
          }
        }
        return '<table>' + match + '</table>';
      });

      // Process unordered lists
      escaped = escaped.replace(/^- (.+)$/gm, '<li>$1</li>');
      escaped = escaped.replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>');

      // Process numbered lists
      escaped = escaped.replace(/^\d+\. (.+)$/gm, '<li>$1</li>');

      // Wrap remaining lines in paragraphs (skip if already wrapped in tags)
      var lines = escaped.split('\n');
      var result = [];

      for (var i = 0; i < lines.length; i++) {
        var line = lines[i].trim();
        if (!line) {
          result.push('');
          continue;
        }
        // Skip lines already wrapped in block tags
        if (line.match(/^<(h[234]|pre|ul|ol|li|p|table|tr|th|td)/) || line.match(/<\/(h[234]|pre|ul|ol|table)>$/)) {
          result.push(line);
        } else if (line.match(/<\/li>$/) || line.match(/<\/tr>$/)) {
          result.push(line);
        } else {
          result.push('<p>' + line + '</p>');
        }
      }

      // Clean up empty paragraphs and fix list wrapping
      var html = result.join('\n')
        .replace(/<p><\/p>/g, '')
        .replace(/<\/ul>\s*<ul>/g, '')
        .replace(/<p>(<ul>)/g, '$1')
        .replace(/(<\/ul>)<\/p>/g, '$1');

      return html;
      } catch (err) {
        console.error('Markdown parsing error:', err);
        return '<p>' + (text || '').replace(/</g, '&lt;').replace(/>/g, '&gt;') + '</p>';
      }
    }
    // ============ END MARKDOWN PARSER ============

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');
    const conceptGroups = document.getElementById('concept-groups');
    const ideasContainer = document.getElementById('ideas-container');
    const canvasContainer = document.getElementById('canvas-container');
    const edgeIndicator = document.getElementById('edge-indicator');

    function resizeCanvas() {
      const container = canvas.parentElement;
      canvas.width = container.clientWidth * window.devicePixelRatio;
      canvas.height = container.clientHeight * window.devicePixelRatio;
      canvas.style.width = container.clientWidth + 'px';
      canvas.style.height = container.clientHeight + 'px';
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      draw();
    }

    function draw() {
      const W = canvas.clientWidth, H = canvas.clientHeight;
      ctx.clearRect(0, 0, W, H);

      // Apply zoom transformation
      ctx.save();
      ctx.scale(zoom.scale, zoom.scale);
      ctx.translate(zoom.offsetX, zoom.offsetY);

      state.edges.forEach(edge => {
        const from = state.concepts.find(c => c.id === edge.from);
        const to = state.concepts.find(c => c.id === edge.to);
        if (!from || !to || !isVisible(from) || !isVisible(to)) return;
        const isConnected = state.selectedConcept && (edge.from === state.selectedConcept || edge.to === state.selectedConcept);
        ctx.beginPath(); ctx.moveTo(from.x, from.y); ctx.lineTo(to.x, to.y);
        if (isConnected) {
          ctx.strokeStyle = edge.cross ? 'rgba(79,195,247,0.7)' : 'rgba(79,195,247,0.9)';
          ctx.lineWidth = Math.max(1, Math.min(5, (edge.cross ? 2.5 : 3) / zoom.scale));
        } else {
          ctx.strokeStyle = edge.cross ? 'rgba(255,255,255,0.15)' : 'rgba(255,255,255,0.25)';
          ctx.lineWidth = Math.max(0.5, Math.min(3, (edge.cross ? 1 : 1.5) / zoom.scale));
        }
        ctx.setLineDash(edge.cross ? [4, 4] : []);
        ctx.stroke();
        const angle = Math.atan2(to.y - from.y, to.x - from.x);
        const dist = Math.sqrt((to.x - from.x) ** 2 + (to.y - from.y) ** 2);
        const arrowX = from.x + Math.cos(angle) * (dist - 30);
        const arrowY = from.y + Math.sin(angle) * (dist - 30);
        ctx.beginPath();
        ctx.moveTo(arrowX, arrowY);
        ctx.lineTo(arrowX - 8 * Math.cos(angle - 0.4), arrowY - 8 * Math.sin(angle - 0.4));
        ctx.moveTo(arrowX, arrowY);
        ctx.lineTo(arrowX - 8 * Math.cos(angle + 0.4), arrowY - 8 * Math.sin(angle + 0.4));
        ctx.stroke();
      });
      ctx.setLineDash([]);
      state.concepts.forEach(concept => {
        if (!isVisible(concept)) return;
        const isSelected = state.selectedConcept === concept.id;
        const radius = isSelected ? 28 : 24;
        if (concept.status === 'explore') {
          ctx.beginPath(); ctx.arc(concept.x, concept.y, radius + 8, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(156, 39, 176, 0.2)'; ctx.fill();
        }
        ctx.beginPath(); ctx.arc(concept.x, concept.y, radius, 0, Math.PI * 2);
        ctx.fillStyle = COLORS[concept.topic] || COLORS.general || '#90a4ae'; ctx.fill();
        ctx.beginPath(); ctx.arc(concept.x, concept.y, radius + 3, 0, Math.PI * 2);
        ctx.strokeStyle = STATUS_COLORS[concept.status]; ctx.lineWidth = Math.max(1, Math.min(5, 3 / zoom.scale)); ctx.stroke();
        if (isSelected) {
          ctx.beginPath(); ctx.arc(concept.x, concept.y, radius + 7, 0, Math.PI * 2);
          ctx.strokeStyle = '#fff'; ctx.lineWidth = Math.max(1, Math.min(4, 2 / zoom.scale)); ctx.stroke();
        }
        ctx.fillStyle = '#fff'; ctx.font = '11px -apple-system, sans-serif';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        const words = concept.name.split(' ');
        if (words.length <= 2) ctx.fillText(concept.name, concept.x, concept.y + radius + 16);
        else {
          const mid = Math.ceil(words.length / 2);
          ctx.fillText(words.slice(0, mid).join(' '), concept.x, concept.y + radius + 12);
          ctx.fillText(words.slice(mid).join(' '), concept.x, concept.y + radius + 24);
        }
        // Draw annotation count badge if node has annotations
        const annCount = state.annotations[concept.id] ? state.annotations[concept.id].length : 0;
        if (annCount > 0) {
          const badgeX = concept.x + radius * 0.7;
          const badgeY = concept.y - radius * 0.7;
          const badgeRadius = 10;
          ctx.beginPath();
          ctx.arc(badgeX, badgeY, badgeRadius, 0, Math.PI * 2);
          ctx.fillStyle = '#f0883e';
          ctx.fill();
          ctx.fillStyle = '#fff';
          ctx.font = 'bold 9px -apple-system, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(annCount.toString(), badgeX, badgeY);
        }
      });

      ctx.restore();
    }

    function isVisible(concept) {
      if (state.activePreset !== 'all' && concept.topic !== state.activePreset) return false;
      if (state.filter !== 'all' && concept.status !== state.filter) return false;
      return true;
    }

    function getActiveTopics() {
      const topics = { ...TOPIC_NAMES };
      if (state.concepts.some(c => c.topic === 'general')) topics.general = 'General / Cross-cutting';
      return topics;
    }

    function renderSidebar() {
      const topics = getActiveTopics();
      while (conceptGroups.firstChild) conceptGroups.removeChild(conceptGroups.firstChild);
      Object.entries(topics).forEach(([key, name]) => {
        const concepts = state.concepts.filter(c => c.topic === key);
        if (concepts.length === 0) return;
        const group = document.createElement('div'); group.className = 'topic-group';
        const header = document.createElement('div'); header.className = 'topic-header';
        const dot = document.createElement('div'); dot.className = 'topic-dot';
        dot.style.background = COLORS[key] || COLORS.general || '#90a4ae';
        header.appendChild(dot);
        const span = document.createElement('span'); span.textContent = name; header.appendChild(span);
        group.appendChild(header);
        const list = document.createElement('div'); list.className = 'concept-list';
        concepts.forEach(c => {
          const item = document.createElement('div');
          item.className = 'concept-item' + (state.selectedConcept === c.id ? ' selected' : '');
          if (state.annotations[c.id] && state.annotations[c.id].length > 0) {
            item.classList.add('has-annotation');
          }
          item.dataset.id = c.id;
          const badge = document.createElement('div'); badge.className = 'status-badge status-' + c.status;
          item.appendChild(badge); item.appendChild(document.createTextNode(c.name));
          if (c.isIdea) {
            const star = document.createElement('span'); star.textContent = ' *';
            star.style.color = COLORS[c.topic]; star.style.fontSize = '10px'; item.appendChild(star);
          }
          item.addEventListener('click', () => { cycleStatus(c); renderSidebar(); draw(); saveState(); });
          list.appendChild(item);
        });
        group.appendChild(list); conceptGroups.appendChild(group);
      });
      // Keep filter buttons in sync with available topics
      initPresetButtons();
    }

    function cycleStatus(concept) {
      const order = ['know', 'fuzzy', 'unknown', 'explore'];
      concept.status = order[(order.indexOf(concept.status) + 1) % order.length];
    }

    function renderIdeas() {
      const ideasContainer = document.getElementById('ideas-container');
      if (!ideasContainer) return;
      while (ideasContainer.firstChild) ideasContainer.removeChild(ideasContainer.firstChild);
      if (state.ideas.length === 0) {
        const msg = document.createElement('div');
        msg.style.cssText = 'color: var(--text-dim); font-size: 12px; padding: 8px;';
        msg.textContent = 'No ideas captured yet. Click "Add Idea" to start.';
        ideasContainer.appendChild(msg); return;
      }
      state.ideas.forEach((idea, idx) => {
        const card = document.createElement('div');
        card.className = 'idea-card' + (idea.selected ? ' selected' : '');
        const header = document.createElement('div'); header.className = 'idea-card-header';
        const title = document.createElement('h4'); title.textContent = idea.title; header.appendChild(title);
        const deleteBtn = document.createElement('button'); deleteBtn.className = 'delete-idea-btn';
        deleteBtn.textContent = 'x';
        deleteBtn.addEventListener('click', (e) => {
          e.stopPropagation(); state.ideas.splice(idx, 1);
          if (idea.id) { const ci = state.concepts.findIndex(c => c.id === idea.id); if (ci !== -1) state.concepts.splice(ci, 1); }
          renderSidebar(); renderIdeas(); draw(); saveState();
        });
        header.appendChild(deleteBtn); card.appendChild(header);
        const desc = document.createElement('p'); desc.textContent = idea.desc; card.appendChild(desc);
        const tag = document.createElement('span'); tag.className = 'topic-tag';
        tag.style.background = (COLORS[idea.topic] || COLORS.general || '#90a4ae') + '40';
        tag.style.color = COLORS[idea.topic] || COLORS.general || '#90a4ae';
        tag.textContent = idea.topic; card.appendChild(tag);
        card.addEventListener('click', () => { idea.selected = !idea.selected; renderIdeas(); saveState(); });
        ideasContainer.appendChild(card);
      });
    }

    function getConceptAt(x, y) { return state.concepts.find(c => isVisible(c) && Math.sqrt((c.x - x) ** 2 + (c.y - y) ** 2) < 28); }

    function getEdgeNear(x, y) {
      for (let i = 0; i < state.edges.length; i++) {
        const edge = state.edges[i];
        const from = state.concepts.find(c => c.id === edge.from);
        const to = state.concepts.find(c => c.id === edge.to);
        if (!from || !to || !isVisible(from) || !isVisible(to)) continue;
        if (pointToLineDist(x, y, from.x, from.y, to.x, to.y) < 10) return { edge, index: i };
      }
      return null;
    }

    function pointToLineDist(px, py, x1, y1, x2, y2) {
      const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
      const dot = A * C + B * D, lenSq = C * C + D * D;
      const param = lenSq ? dot / lenSq : -1;
      const xx = param < 0 ? x1 : param > 1 ? x2 : x1 + param * C;
      const yy = param < 0 ? y1 : param > 1 ? y2 : y1 + param * D;
      return Math.sqrt((px - xx) ** 2 + (py - yy) ** 2);
    }

    canvas.addEventListener('mousedown', e => {
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left, screenY = e.clientY - rect.top;
      const world = zoom.screenToWorld(screenX, screenY);
      const concept = getConceptAt(world.x, world.y);
      if (state.edgeMode) {
        if (concept) {
          if (!state.edgeSource) {
            state.edgeSource = concept;
            edgeIndicator.textContent = 'Now click target node... (ESC to cancel)';
            state.selectedConcept = concept.id; renderSidebar(); draw();
          } else if (concept.id !== state.edgeSource.id) {
            const exists = state.edges.some(e => (e.from === state.edgeSource.id && e.to === concept.id) || (e.from === concept.id && e.to === state.edgeSource.id));
            if (!exists) { state.edges.push({ from: state.edgeSource.id, to: concept.id, cross: concept.topic !== state.edgeSource.topic, userCreated: true }); saveState(); }
            state.edgeSource = null; edgeIndicator.textContent = 'Click source node...'; draw();
          }
        }
        return;
      }
      if (state.deleteEdgeMode) { const edgeResult = getEdgeNear(world.x, world.y); if (edgeResult) { state.edges.splice(edgeResult.index, 1); draw(); saveState(); } return; }
      if (concept) {
        state.dragging = concept;
        state.dragOffset = { x: world.x - concept.x, y: world.y - concept.y };
        state.selectedConcept = concept.id;
        // Show history panel if node has annotations
        if (state.annotations[concept.id] && state.annotations[concept.id].length > 0) {
          showHistoryPanel(concept.id);
        }
        renderSidebar();
        draw();
      }
    });

    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      const screenX = e.clientX - rect.left, screenY = e.clientY - rect.top;
      const world = zoom.screenToWorld(screenX, screenY);
      if (state.dragging) { state.dragging.x = world.x - state.dragOffset.x; state.dragging.y = world.y - state.dragOffset.y; draw(); }
      else {
        const concept = getConceptAt(world.x, world.y);
        if (concept) {
          tooltip.querySelector('.tooltip-title').textContent = concept.name;
          tooltip.querySelector('.tooltip-desc').textContent = concept.desc;
          tooltip.style.left = (screenX + 20) + 'px'; tooltip.style.top = (screenY - 10) + 'px';
          tooltip.classList.add('visible');
        } else { tooltip.classList.remove('visible'); }
      }
    });

    canvas.addEventListener('mouseup', () => { if (state.dragging) saveState(); state.dragging = null; });
    canvas.addEventListener('dblclick', e => {
      const rect = canvas.getBoundingClientRect();
      const world = zoom.screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
      const concept = getConceptAt(world.x, world.y);
      if (concept) { cycleStatus(concept); renderSidebar(); draw(); saveState(); }
    });

    function initPresetButtons() {
      const container = document.getElementById('presets-container');
      // Add click handler for existing "All Topics" button
      const allBtn = container.querySelector('[data-preset="all"]');
      if (allBtn && !allBtn.hasAttribute('data-initialized')) {
        allBtn.setAttribute('data-initialized', 'true');
        allBtn.addEventListener('click', () => {
          document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
          allBtn.classList.add('active'); state.activePreset = 'all'; draw();
        });
      }
      // Restore active state for "All Topics" button when activePreset is 'all'
      if (allBtn) {
        if (state.activePreset === 'all') allBtn.classList.add('active');
        else allBtn.classList.remove('active');
      }
      // Remove existing dynamic topic buttons (keep All Topics and Export)
      container.querySelectorAll('.preset-btn.dynamic-topic').forEach(btn => btn.remove());
      // Add topic-specific buttons
      const topics = getActiveTopics();
      Object.entries(topics).forEach(([key, name]) => {
        const btn = document.createElement('button');
        btn.className = 'preset-btn dynamic-topic'; btn.dataset.preset = key; btn.textContent = name;
        if (state.activePreset === key) btn.classList.add('active');
        btn.addEventListener('click', () => {
          document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active'); state.activePreset = key; draw();
        });
        container.appendChild(btn);
      });
    }

    function initTopicSelect() {
      const select = document.getElementById('idea-topic');
      Object.entries(TOPIC_NAMES).forEach(([key, name]) => {
        const opt = document.createElement('option'); opt.value = key; opt.textContent = name;
        select.appendChild(opt);
      });
      const genOpt = document.createElement('option'); genOpt.value = 'general'; genOpt.textContent = 'General / Cross-cutting';
      select.appendChild(genOpt);
    }

    const edgeModeBtn = document.getElementById('edge-mode-btn');
    const deleteEdgeBtn = document.getElementById('delete-edge-btn');

    edgeModeBtn.addEventListener('click', () => {
      state.edgeMode = !state.edgeMode; state.deleteEdgeMode = false; state.edgeSource = null;
      edgeModeBtn.classList.toggle('active', state.edgeMode); deleteEdgeBtn.classList.remove('active');
      canvasContainer.classList.toggle('edge-mode', state.edgeMode);
      edgeIndicator.classList.toggle('visible', state.edgeMode);
      edgeIndicator.textContent = 'Click source node...';
    });

    deleteEdgeBtn.addEventListener('click', () => {
      state.deleteEdgeMode = !state.deleteEdgeMode; state.edgeMode = false; state.edgeSource = null;
      deleteEdgeBtn.classList.toggle('active', state.deleteEdgeMode); edgeModeBtn.classList.remove('active');
      canvasContainer.classList.toggle('edge-mode', state.deleteEdgeMode);
      edgeIndicator.classList.toggle('visible', state.deleteEdgeMode);
      edgeIndicator.textContent = state.deleteEdgeMode ? 'Click on an edge to delete...' : '';
    });

    document.addEventListener('keydown', e => {
      if (e.key === 'Escape') {
        state.edgeMode = state.deleteEdgeMode = false; state.edgeSource = null;
        edgeModeBtn.classList.remove('active'); deleteEdgeBtn.classList.remove('active');
        canvasContainer.classList.remove('edge-mode'); edgeIndicator.classList.remove('visible');
      }
    });

    document.getElementById('reset-btn').addEventListener('click', clearState);

    document.getElementById('export-btn').addEventListener('click', function() {
      exportBrainstormFindings();
    });

    // ============ DOCUMENTATION EXPORT ============
    function exportBrainstormFindings() {
      if (!bridgeAvailable) {
        alert('AI not connected. Please ensure the AI bridge is running to generate documentation.');
        return;
      }

      // Show loading state
      var exportBtn = document.getElementById('export-btn');
      var originalText = exportBtn.textContent;
      exportBtn.textContent = 'Generating...';
      exportBtn.disabled = true;

      // Build comprehensive context for AI
      var context = {
        projectName: PROJECT_NAME,
        topicNames: TOPIC_NAMES,
        colors: COLORS,
        concepts: state.concepts,
        edges: state.edges,
        ideas: state.ideas,
        annotations: state.annotations,
        prompt: buildBrainstormExportPrompt()
      };

      window.BridgeClient.sendAndWait('export-documentation', 'export', 'brainstorm', context).then(function(response) {
        exportBtn.textContent = originalText;
        exportBtn.disabled = false;

        var date = new Date().toISOString().split('T')[0];
        var filename = PROJECT_NAME.toLowerCase().replace(/\s+/g, '-') + '-findings-' + date + '.md';
        downloadMarkdownFile(response.content, filename);
      }).catch(function(err) {
        exportBtn.textContent = originalText;
        exportBtn.disabled = false;
        console.error('Export failed:', err);
        alert('Failed to generate documentation: ' + err.message);
      });
    }

    function buildBrainstormExportPrompt() {
      var statusCounts = { know: 0, fuzzy: 0, unknown: 0, explore: 0 };
      (state.concepts || []).forEach(function(c) { if (c && c.status) statusCounts[c.status]++; });

      var totalConcepts = (state.concepts || []).length;
      var totalIdeas = (state.ideas || []).length;
      var totalConnections = (state.edges || []).length;
      var annotationCounts = { question: 0, comment: 0, edit: 0, ai: 0 };
      Object.values(state.annotations || {}).forEach(function(anns) {
        if (!anns || !Array.isArray(anns)) return;
        anns.forEach(function(a) {
          if (a && a.type) annotationCounts[a.type] = (annotationCounts[a.type] || 0) + 1;
        });
      });

      return 'Generate a comprehensive research brief document in Markdown format for the brainstorming session "' + PROJECT_NAME + '".\n\n' +
        'You have access to the complete brainstorm data including:\n' +
        '- ' + totalConcepts + ' concepts organized across ' + Object.keys(TOPIC_NAMES).length + ' topics\n' +
        '- Status distribution: Know=' + statusCounts.know + ', Fuzzy=' + statusCounts.fuzzy + ', Unknown=' + statusCounts.unknown + ', Explore=' + statusCounts.explore + '\n' +
        '- ' + totalConnections + ' connections/relationships between concepts\n' +
        '- ' + totalIdeas + ' captured ideas/innovations\n' +
        '- ' + annotationCounts.ai + ' AI analysis insights gathered during exploration\n' +
        '- ' + annotationCounts.question + ' questions raised\n' +
        '- ' + annotationCounts.comment + ' observations and comments\n\n' +
        'Create a polished, professional research brief that:\n' +
        '1. Opens with an executive summary synthesizing the key themes and findings\n' +
        '2. Presents a knowledge assessment - what is well understood vs. needs more exploration\n' +
        '3. Organizes concepts by topic with insights integrated into each section\n' +
        '4. Highlights interesting connections and cross-topic relationships\n' +
        '5. Documents captured ideas and innovations with context on why they emerged\n' +
        '6. Integrates AI insights and user annotations naturally (not as separate lists)\n' +
        '7. Identifies gaps, open questions, and areas needing further research\n' +
        '8. Concludes with key takeaways and recommended next steps\n\n' +
        'The document should read as a cohesive research synthesis, not a data dump. ' +
        'Tell a story about the exploration journey and what was learned.\n\n' +
        'Return ONLY the markdown content, no preamble or explanation.';
    }

    function downloadMarkdownFile(content, filename) {
      var blob = new Blob([content], { type: 'text/markdown;charset=utf-8' });
      var url = URL.createObjectURL(blob);
      var link = document.createElement('a');
      link.href = url;
      link.download = filename;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      setTimeout(function() {
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      }, 100);
    }
    // ============ END DOCUMENTATION EXPORT ============

    document.querySelectorAll('.legend-item').forEach(item => {
      item.addEventListener('click', () => {
        document.querySelectorAll('.legend-item').forEach(i => i.classList.remove('active'));
        item.classList.add('active'); state.filter = item.dataset.status; draw();
      });
    });

    const ideaModal = document.getElementById('idea-modal');
    document.getElementById('add-idea-btn').addEventListener('click', () => { ideaModal.classList.add('visible'); document.getElementById('idea-title').focus(); });
    document.getElementById('cancel-idea').addEventListener('click', () => ideaModal.classList.remove('visible'));
    ideaModal.addEventListener('click', e => { if (e.target === ideaModal) ideaModal.classList.remove('visible'); });

    document.getElementById('save-idea').addEventListener('click', () => {
      const title = document.getElementById('idea-title').value.trim();
      const desc = document.getElementById('idea-desc').value.trim();
      const topic = document.getElementById('idea-topic').value;
      if (title && desc) {
        const ideaId = 'idea-' + Date.now();
        state.ideas.push({ id: ideaId, title, desc, topic, selected: true });
        const topicNodes = state.concepts.filter(c => c.topic === topic);
        let newX = 400 + Math.random() * 100, newY = 300 + Math.random() * 100;
        if (topicNodes.length > 0) { const last = topicNodes[topicNodes.length - 1]; newX = last.x + 80 + Math.random() * 40; newY = last.y + 60 + Math.random() * 40; }
        state.concepts.push({ id: ideaId, topic, name: title, desc, status: 'explore', x: newX, y: newY, isIdea: true });
        document.getElementById('idea-title').value = ''; document.getElementById('idea-desc').value = '';
        ideaModal.classList.remove('visible');
        renderSidebar(); renderIdeas(); draw(); saveState();
      }
    });

    function saveState() {
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify({ concepts: state.concepts, edges: state.edges, ideas: state.ideas, annotations: state.annotations, version: 1 })); }
      catch (e) { console.warn('Failed to save:', e); }
    }

    function loadState() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          const p = JSON.parse(saved);
          if (p.version === 1) { state.concepts = p.concepts || state.concepts; state.edges = p.edges || state.edges; state.ideas = p.ideas || state.ideas; state.annotations = p.annotations || {}; return true; }
        }
      } catch (e) { console.warn('Failed to load:', e); }
      return false;
    }

    function clearState() {
      if (confirm('Reset playground to default state? This will clear all your changes.')) { localStorage.removeItem(STORAGE_KEY); localStorage.removeItem(STORAGE_KEY + '-zoom'); location.reload(); }
    }

    // ============ ZOOM EVENT LISTENERS ============
    document.getElementById('zoom-in').addEventListener('click', () => zoom.zoomIn());
    document.getElementById('zoom-out').addEventListener('click', () => zoom.zoomOut());
    document.getElementById('zoom-reset').addEventListener('click', () => zoom.reset());
    document.getElementById('zoom-fit').addEventListener('click', () => zoom.fitToView());

    // Mouse wheel zoom (Ctrl/Cmd + wheel)
    canvas.addEventListener('wheel', e => {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        zoom.zoomToPoint(e.deltaY, e.clientX, e.clientY);
      }
    }, { passive: false });

    // Keyboard shortcuts for zoom
    document.addEventListener('keydown', e => {
      // Only handle if not focused on input elements
      if (['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName)) return;

      if ((e.ctrlKey || e.metaKey) && e.key === '0') {
        e.preventDefault();
        zoom.reset();
      } else if ((e.ctrlKey || e.metaKey) && (e.key === '=' || e.key === '+')) {
        e.preventDefault();
        zoom.zoomIn();
      } else if ((e.ctrlKey || e.metaKey) && e.key === '-') {
        e.preventDefault();
        zoom.zoomOut();
      }
    });
    // ============ END ZOOM EVENT LISTENERS ============

    // ============ AI BRIDGE INTEGRATION ============
    let bridgeAvailable = false;
    const aiContextMenu = document.getElementById('ai-context-menu');
    const aiResponsePanel = document.getElementById('ai-response-panel');
    let historyPanelActive = false;

    function updateBridgeStatus(connected) {
      bridgeAvailable = connected;
      const statusEl = document.getElementById('bridge-status');
      const textEl = statusEl.querySelector('.status-text');
      statusEl.classList.remove('connected', 'disconnected', 'connecting');
      statusEl.classList.add(connected ? 'connected' : 'disconnected');
      textEl.textContent = connected ? 'AI Connected' : 'AI Disconnected';

      // Update AI action items visibility
      document.querySelectorAll('.ai-context-item').forEach(item => {
        item.classList.toggle('disabled', !connected);
      });
    }

    function initBridgeClient() {
      if (!window.BridgeClient) {
        console.log('Bridge client not available - AI features disabled');
        updateBridgeStatus(false);
        return;
      }

      // Set up connection monitoring
      window.BridgeClient.onStatusChange(updateBridgeStatus);
      window.BridgeClient.startConnectionMonitor(10000);

      // Set up AI action handlers
      setupAIContextMenu();
    }

    function setupAIContextMenu() {
      // Right-click handler for canvas
      canvas.addEventListener('contextmenu', e => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const screenX = e.clientX - rect.left;
        const screenY = e.clientY - rect.top;
        const world = zoom.screenToWorld(screenX, screenY);

        // Find clicked concept
        const concept = state.concepts.find(c => {
          const dx = c.x - world.x;
          const dy = c.y - world.y;
          return Math.sqrt(dx * dx + dy * dy) < 30; // Node radius
        });

        if (concept && bridgeAvailable) {
          state.contextTarget = concept.id;
          aiContextMenu.style.left = e.clientX + 'px';
          aiContextMenu.style.top = e.clientY + 'px';
          aiContextMenu.classList.add('visible');
        } else {
          hideAIContextMenu();
        }
      });

      // Click handlers for AI actions
      document.querySelectorAll('.ai-context-item').forEach(item => {
        item.addEventListener('click', () => {
          if (!state.contextTarget) return;
          const action = item.dataset.action;

          // Handle user annotation actions (don't require bridge)
          if (action === 'add-question' || action === 'add-comment' || action === 'mark-edit') {
            openAnnotationModal(state.contextTarget, action);
            hideAIContextMenu();
            return;
          }

          // AI actions require bridge connection
          if (!bridgeAvailable) return;

          if (action === 'modify-graph') {
            openGraphModifyModal(state.contextTarget);
          } else if (action) {
            triggerAIAction(action, state.contextTarget);
          }
          hideAIContextMenu();
        });
      });

      // Close menu on outside click
      document.addEventListener('click', e => {
        if (!aiContextMenu.contains(e.target)) {
          hideAIContextMenu();
        }
      });

      // Close response panel
      document.getElementById('ai-response-close').addEventListener('click', () => {
        aiResponsePanel.classList.remove('visible');
      });
    }

    function hideAIContextMenu() {
      aiContextMenu.classList.remove('visible');
    }

    // ============ QUESTION MODAL ============
    let questionTargetConcept = null;

    function openQuestionModal(conceptId) {
      const concept = state.concepts.find(c => c.id === conceptId);
      if (!concept) return;

      questionTargetConcept = conceptId;
      document.getElementById('question-modal-title').textContent = 'Ask about: ' + concept.name;
      document.getElementById('question-text').value = '';
      document.getElementById('question-modal').classList.add('visible');
      document.getElementById('question-text').focus();
    }

    document.getElementById('cancel-question').addEventListener('click', () => {
      document.getElementById('question-modal').classList.remove('visible');
      questionTargetConcept = null;
    });

    document.getElementById('send-question').addEventListener('click', () => {
      const questionText = document.getElementById('question-text').value.trim();
      if (questionText && questionTargetConcept && bridgeAvailable) {
        triggerAIQuestion(questionTargetConcept, questionText);
      }
      document.getElementById('question-modal').classList.remove('visible');
      questionTargetConcept = null;
    });

    // Handle Enter key in question modal
    document.getElementById('question-text').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        document.getElementById('send-question').click();
      }
    });

    function triggerAIQuestion(conceptId, questionText) {
      if (state.pendingAIRequests[conceptId]) {
        console.log('AI request already pending for', conceptId);
        return;
      }

      const concept = state.concepts.find(c => c.id === conceptId);
      if (!concept) return;

      const context = {
        nodeTitle: concept.name,
        nodeDescription: concept.desc || '',
        projectName: PROJECT_NAME,
        status: concept.status,
        topic: concept.topic,
        prompt: questionText + '\n\nContext: Brainstorming "' + concept.name + '" in ' + PROJECT_NAME + '\nCurrent understanding: ' + concept.status
      };

      state.pendingAIRequests[conceptId] = true;
      showNodeLoadingOverlay(conceptId);
      draw();

      window.BridgeClient.sendAndWait('question', conceptId, 'brainstorm', context).then(response => {
        delete state.pendingAIRequests[conceptId];
        hideNodeLoadingOverlay(conceptId);

        // Store response as annotation
        if (!state.annotations[conceptId]) state.annotations[conceptId] = [];
        state.annotations[conceptId].unshift({
          type: 'ai',
          action: 'question',
          question: questionText,
          text: response.content,
          timestamp: Date.now(),
          collapsed: false
        });
        saveState();

        // Show in response panel (parseMarkdown escapes HTML for XSS safety)
        document.getElementById('ai-response-title').textContent = 'Q: ' + questionText.substring(0, 30) + (questionText.length > 30 ? '...' : '');
        const contentEl = document.getElementById('ai-response-content');
        contentEl.classList.add('markdown');
        contentEl.innerHTML = parseMarkdown(response.content);
        aiResponsePanel.classList.add('visible');

        renderSidebar();
        draw();
      }).catch(err => {
        delete state.pendingAIRequests[conceptId];
        hideNodeLoadingOverlay(conceptId);
        draw();
        console.error('AI question failed:', err);
        alert('AI request failed: ' + err.message);
      });
    }
    // ============ END QUESTION MODAL ============

    // ============ ANNOTATION MODAL ============
    let annotationTargetConcept = null;

    function openAnnotationModal(conceptId, action) {
      const concept = state.concepts.find(c => c.id === conceptId);
      if (!concept) return;

      annotationTargetConcept = conceptId;
      const typeMap = { 'add-question': 'question', 'add-comment': 'comment', 'mark-edit': 'edit' };
      const type = typeMap[action] || 'question';

      document.getElementById('annotation-modal-title').textContent = 'Annotate: ' + concept.name;
      document.getElementById('annotation-type-select').value = type;
      document.getElementById('annotation-text').value = '';
      document.getElementById('annotation-modal').classList.add('visible');
      document.getElementById('annotation-text').focus();
    }

    document.getElementById('cancel-annotation').addEventListener('click', () => {
      document.getElementById('annotation-modal').classList.remove('visible');
      annotationTargetConcept = null;
    });

    document.getElementById('save-annotation').addEventListener('click', () => {
      const type = document.getElementById('annotation-type-select').value;
      const text = document.getElementById('annotation-text').value.trim();

      if (text && annotationTargetConcept) {
        if (!state.annotations[annotationTargetConcept]) state.annotations[annotationTargetConcept] = [];
        state.annotations[annotationTargetConcept].unshift({
          type: type,
          text: text,
          timestamp: Date.now()
        });
        saveState();
        renderSidebar();
        if (historyPanelActive) showHistoryPanel(annotationTargetConcept);

        // Trigger AI response for questions if bridge is available
        if (type === 'question' && bridgeAvailable) {
          triggerAIQuestion(annotationTargetConcept, text);
        }
      }
      document.getElementById('annotation-modal').classList.remove('visible');
      annotationTargetConcept = null;
    });
    // ============ END ANNOTATION MODAL ============

    // ============ GRAPH MODIFY MODAL ============
    let graphModifyTargetConcept = null;

    function openGraphModifyModal(conceptId) {
      const concept = state.concepts.find(c => c.id === conceptId);
      if (!concept) return;

      graphModifyTargetConcept = conceptId;
      document.getElementById('graph-modify-title').textContent = 'AI: Modify Graph around "' + concept.name + '"';
      document.getElementById('graph-modify-text').value = '';
      document.getElementById('graph-modify-modal').classList.add('visible');
      document.getElementById('graph-modify-text').focus();
    }

    document.getElementById('cancel-graph-modify').addEventListener('click', () => {
      document.getElementById('graph-modify-modal').classList.remove('visible');
      graphModifyTargetConcept = null;
    });

    document.getElementById('send-graph-modify').addEventListener('click', () => {
      const requestText = document.getElementById('graph-modify-text').value.trim();
      if (requestText && graphModifyTargetConcept && bridgeAvailable) {
        triggerGraphModification(graphModifyTargetConcept, requestText);
      }
      document.getElementById('graph-modify-modal').classList.remove('visible');
      graphModifyTargetConcept = null;
    });

    function triggerGraphModification(conceptId, requestText) {
      if (state.pendingAIRequests[conceptId]) {
        console.log('AI request already pending for', conceptId);
        return;
      }

      const concept = state.concepts.find(c => c.id === conceptId);
      if (!concept) return;

      // Serialize current graph state
      const currentGraph = {
        nodes: state.concepts.map(c => ({
          id: c.id, name: c.name, desc: c.desc, topic: c.topic,
          status: c.status, x: Math.round(c.x), y: Math.round(c.y), isIdea: c.isIdea || false
        })),
        edges: state.edges.map(e => ({
          from: e.from, to: e.to, cross: e.cross || false
        }))
      };

      const context = {
        nodeTitle: concept.name,
        nodeDescription: concept.desc || '',
        projectName: PROJECT_NAME,
        currentGraph: currentGraph,
        prompt: requestText + '\n\nReturn a JSON response with modifications object containing: addNodes, removeNodes, updateNodes, addEdges, removeEdges arrays. Only modify the data, never HTML.'
      };

      state.pendingAIRequests[conceptId] = true;
      showNodeLoadingOverlay(conceptId);
      draw();

      window.BridgeClient.sendAndWait('modify-graph', conceptId, 'brainstorm', context).then(response => {
        delete state.pendingAIRequests[conceptId];
        hideNodeLoadingOverlay(conceptId);

        // Try to parse and apply modifications
        try {
          applyGraphModifications(response.content, conceptId, requestText);
        } catch (err) {
          console.error('Failed to apply modifications:', err);
          // Store as regular annotation if parsing fails
          if (!state.annotations[conceptId]) state.annotations[conceptId] = [];
          state.annotations[conceptId].unshift({
            type: 'ai',
            action: 'modify-graph',
            text: response.content,
            timestamp: Date.now(),
            collapsed: false
          });
        }

        saveState();
        renderSidebar();
        draw();
      }).catch(err => {
        delete state.pendingAIRequests[conceptId];
        hideNodeLoadingOverlay(conceptId);
        draw();
        console.error('Graph modification failed:', err);
        alert('AI request failed: ' + err.message);
      });
    }

    function applyGraphModifications(content, conceptId, originalRequest) {
      // Try to extract JSON from the response
      let modifications;
      const jsonMatch = content.match(/\{[\s\S]*"modifications"[\s\S]*\}/);
      if (jsonMatch) {
        const parsed = JSON.parse(jsonMatch[0]);
        modifications = parsed.modifications || parsed;
      } else {
        throw new Error('No valid modifications JSON found in response');
      }

      let changeCount = 0;

      // Remove nodes
      if (modifications.removeNodes && Array.isArray(modifications.removeNodes)) {
        modifications.removeNodes.forEach(nodeId => {
          const idx = state.concepts.findIndex(c => c.id === nodeId);
          if (idx !== -1) {
            state.concepts.splice(idx, 1);
            state.edges = state.edges.filter(e => e.from !== nodeId && e.to !== nodeId);
            changeCount++;
          }
        });
      }

      // Update nodes
      if (modifications.updateNodes && Array.isArray(modifications.updateNodes)) {
        modifications.updateNodes.forEach(update => {
          const concept = state.concepts.find(c => c.id === update.id);
          if (concept && update.changes) {
            if (update.changes.name) concept.name = update.changes.name;
            if (update.changes.desc) concept.desc = update.changes.desc;
            if (update.changes.status) concept.status = update.changes.status;
            changeCount++;
          }
        });
      }

      // Add nodes
      if (modifications.addNodes && Array.isArray(modifications.addNodes)) {
        const targetConcept = state.concepts.find(c => c.id === conceptId);
        modifications.addNodes.forEach((node, i) => {
          if (!node.id || !node.name) return;
          if (state.concepts.find(c => c.id === node.id)) return; // Skip duplicates
          state.concepts.push({
            id: node.id,
            name: node.name,
            desc: node.desc || '',
            topic: node.topic || (targetConcept ? targetConcept.topic : 'general'),
            status: node.status || 'fuzzy',
            x: node.x || (targetConcept ? targetConcept.x + 100 + i * 80 : 400 + Math.random() * 200),
            y: node.y || (targetConcept ? targetConcept.y + 50 + i * 60 : 300 + Math.random() * 200),
            isIdea: true
          });
          changeCount++;
        });
      }

      // Remove edges
      if (modifications.removeEdges && Array.isArray(modifications.removeEdges)) {
        modifications.removeEdges.forEach(edge => {
          const idx = state.edges.findIndex(e => e.from === edge.from && e.to === edge.to);
          if (idx !== -1) {
            state.edges.splice(idx, 1);
            changeCount++;
          }
        });
      }

      // Add edges
      if (modifications.addEdges && Array.isArray(modifications.addEdges)) {
        modifications.addEdges.forEach(edge => {
          const fromExists = state.concepts.find(c => c.id === edge.from);
          const toExists = state.concepts.find(c => c.id === edge.to);
          if (fromExists && toExists) {
            const exists = state.edges.some(e => e.from === edge.from && e.to === edge.to);
            if (!exists) {
              state.edges.push({
                from: edge.from,
                to: edge.to,
                cross: fromExists.topic !== toExists.topic,
                userCreated: true
              });
              changeCount++;
            }
          }
        });
      }

      // Store modification record as annotation
      if (!state.annotations[conceptId]) state.annotations[conceptId] = [];
      state.annotations[conceptId].unshift({
        type: 'ai',
        action: 'modify-graph',
        text: 'Graph modified: ' + changeCount + ' changes applied.\n\nRequest: ' + originalRequest + '\n\n' + (modifications.explanation || ''),
        timestamp: Date.now(),
        collapsed: false
      });

      console.log('Applied', changeCount, 'graph modifications');
    }
    // ============ END GRAPH MODIFY MODAL ============

    // ============ NODE LOADING OVERLAY ============
    function showNodeLoadingOverlay(conceptId) {
      const concept = state.concepts.find(c => c.id === conceptId);
      if (!concept) return;

      hideNodeLoadingOverlay(conceptId);

      const overlay = document.createElement('div');
      overlay.className = 'node-ai-loading';
      overlay.id = 'loading-' + conceptId;

      // Calculate screen position with zoom
      const screenX = (concept.x + zoom.offsetX) * zoom.scale;
      const screenY = (concept.y + zoom.offsetY) * zoom.scale;

      overlay.style.left = (screenX - 30) + 'px';
      overlay.style.top = (screenY - 30) + 'px';
      overlay.style.width = '60px';
      overlay.style.height = '60px';

      const spinner = document.createElement('div');
      spinner.className = 'spinner';
      overlay.appendChild(spinner);

      canvasContainer.appendChild(overlay);
    }

    function hideNodeLoadingOverlay(conceptId) {
      const overlay = document.getElementById('loading-' + conceptId);
      if (overlay) overlay.remove();
    }

    // ============ RESPONSE HISTORY PANEL ============
    function formatTimestamp(ts) {
      const d = new Date(ts);
      const now = new Date();
      const diff = now - d;
      if (diff < 60000) return 'just now';
      if (diff < 3600000) return Math.floor(diff / 60000) + 'm ago';
      if (diff < 86400000) return Math.floor(diff / 3600000) + 'h ago';
      return d.toLocaleDateString();
    }

    function showHistoryPanel(conceptId) {
      const concept = state.concepts.find(c => c.id === conceptId);
      if (!concept) return;

      const annotations = state.annotations[conceptId] || [];
      historyPanelActive = true;

      const rightPanel = document.querySelector('.right-panel');
      rightPanel.textContent = '';

      // Header
      const header = document.createElement('div');
      header.className = 'history-header';

      const headerInfo = document.createElement('div');
      const title = document.createElement('h3');
      title.textContent = concept.name;
      headerInfo.appendChild(title);

      const subtitle = document.createElement('div');
      subtitle.className = 'history-subtitle';
      subtitle.textContent = annotations.length + ' response' + (annotations.length !== 1 ? 's' : '');
      headerInfo.appendChild(subtitle);
      header.appendChild(headerInfo);

      const headerActions = document.createElement('div');
      headerActions.className = 'history-header-actions';

      const viewIdeasBtn = document.createElement('button');
      viewIdeasBtn.className = 'view-ideas-btn';
      viewIdeasBtn.textContent = 'View Ideas';
      viewIdeasBtn.addEventListener('click', hideHistoryPanel);
      headerActions.appendChild(viewIdeasBtn);

      const closeBtn = document.createElement('button');
      closeBtn.className = 'close-history-btn';
      closeBtn.textContent = '\u00D7';
      closeBtn.addEventListener('click', hideHistoryPanel);
      headerActions.appendChild(closeBtn);

      header.appendChild(headerActions);

      rightPanel.appendChild(header);

      // Annotations container
      const historyContainer = document.createElement('div');
      historyContainer.className = 'annotations-history';

      if (annotations.length === 0) {
        const empty = document.createElement('div');
        empty.className = 'empty-history';
        empty.textContent = 'No AI responses yet. Right-click this node to ask AI.';
        historyContainer.appendChild(empty);
      } else {
        annotations.forEach((ann, idx) => {
          const item = document.createElement('div');
          item.className = 'annotation-item' + (ann.type === 'ai' ? ' ai-annotation' : '');

          // Header with type and delete
          const itemHeader = document.createElement('div');
          itemHeader.className = 'annotation-header';

          const typeLabel = document.createElement('span');
          typeLabel.className = 'annotation-type';
          typeLabel.textContent = ann.type === 'ai' ? 'AI: ' + (ann.action || 'response') : ann.type;
          itemHeader.appendChild(typeLabel);

          const timeLabel = document.createElement('span');
          timeLabel.className = 'annotation-time';
          timeLabel.textContent = formatTimestamp(ann.timestamp);
          itemHeader.appendChild(timeLabel);

          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'annotation-delete';
          deleteBtn.textContent = '\u00D7';
          deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            state.annotations[conceptId].splice(idx, 1);
            if (state.annotations[conceptId].length === 0) delete state.annotations[conceptId];
            saveState();
            renderSidebar();
            showHistoryPanel(conceptId);
          });
          itemHeader.appendChild(deleteBtn);

          item.appendChild(itemHeader);

          // Expand/collapse button at top for long responses
          let expandBtn = null;
          if (ann.type === 'ai' && ann.text && ann.text.length > 500) {
            expandBtn = document.createElement('button');
            expandBtn.className = 'annotation-expand-btn';
            expandBtn.textContent = ann.collapsed ? 'Show more' : 'Show less';
            expandBtn.addEventListener('click', () => {
              ann.collapsed = !ann.collapsed;
              saveState();
              showHistoryPanel(conceptId);
            });
            item.appendChild(expandBtn);
          }

          // Content with markdown rendering (parseMarkdown escapes HTML for XSS safety)
          const textContainer = document.createElement('div');
          textContainer.className = 'annotation-text' + (ann.collapsed ? ' annotation-collapsed' : '');
          if (ann.type === 'ai') {
            textContainer.classList.add('markdown');
            // parseMarkdown escapes all HTML before processing, safe to use innerHTML
            textContainer.innerHTML = parseMarkdown(ann.text);
          } else {
            textContainer.textContent = ann.text;
          }
          item.appendChild(textContainer);

          historyContainer.appendChild(item);
        });
      }

      rightPanel.appendChild(historyContainer);
    }

    function hideHistoryPanel() {
      historyPanelActive = false;
      state.selectedConcept = null;
      restoreRightPanel();
      renderSidebar();
      draw();
    }

    function restoreRightPanel() {
      const rightPanel = document.querySelector('.right-panel');
      rightPanel.textContent = '';

      // Legend section
      const legendSection = document.createElement('div');
      legendSection.className = 'panel-section';
      const legendTitle = document.createElement('h3');
      legendTitle.textContent = 'Status Legend (click to filter)';
      legendSection.appendChild(legendTitle);

      const legend = document.createElement('div');
      legend.className = 'legend';

      const statuses = [
        { status: 'all', label: 'All', style: 'background: var(--text-dim)' },
        { status: 'know', label: 'Know', className: 'status-know' },
        { status: 'fuzzy', label: 'Fuzzy', className: 'status-fuzzy' },
        { status: 'unknown', label: 'Unknown', className: 'status-unknown' },
        { status: 'explore', label: 'Explore', className: 'status-explore' }
      ];

      statuses.forEach(s => {
        const item = document.createElement('div');
        item.className = 'legend-item' + (state.filter === s.status ? ' active' : '');
        item.dataset.status = s.status;

        const badge = document.createElement('div');
        badge.className = 'status-badge' + (s.className ? ' ' + s.className : '');
        if (s.style) badge.style.cssText = s.style;
        item.appendChild(badge);
        item.appendChild(document.createTextNode(s.label));

        item.addEventListener('click', () => {
          document.querySelectorAll('.legend-item').forEach(i => i.classList.remove('active'));
          item.classList.add('active');
          state.filter = s.status;
          draw();
        });

        legend.appendChild(item);
      });

      legendSection.appendChild(legend);
      rightPanel.appendChild(legendSection);

      // Ideas section
      const ideasSection = document.createElement('div');
      ideasSection.className = 'panel-section';
      const ideasTitle = document.createElement('h3');
      ideasTitle.textContent = 'Captured Ideas';
      ideasSection.appendChild(ideasTitle);

      const ideasContainerEl = document.createElement('div');
      ideasContainerEl.className = 'ideas-container';
      ideasContainerEl.id = 'ideas-container';
      ideasSection.appendChild(ideasContainerEl);

      const addIdeaBtn = document.createElement('button');
      addIdeaBtn.className = 'add-idea-btn';
      addIdeaBtn.id = 'add-idea-btn';
      addIdeaBtn.textContent = '+ Add Idea';
      addIdeaBtn.addEventListener('click', () => {
        document.getElementById('idea-modal').classList.add('visible');
        document.getElementById('idea-title').focus();
      });
      ideasSection.appendChild(addIdeaBtn);

      rightPanel.appendChild(ideasSection);

      renderIdeas();
    }

    function triggerAIAction(action, conceptId) {
      if (state.pendingAIRequests[conceptId]) {
        console.log('AI request already pending for', conceptId);
        return;
      }

      const concept = state.concepts.find(c => c.id === conceptId);
      if (!concept) return;

      const neighbors = state.edges
        .filter(e => e.from === conceptId || e.to === conceptId)
        .map(e => e.from === conceptId ? e.to : e.from)
        .map(id => state.concepts.find(c => c.id === id))
        .filter(Boolean)
        .map(c => c.name);

      const context = {
        nodeTitle: concept.name,
        nodeDescription: concept.desc || '',
        projectName: PROJECT_NAME,
        neighbors: neighbors
      };

      state.pendingAIRequests[conceptId] = true;
      showNodeLoadingOverlay(conceptId);
      draw();

      if (window.generateAIPrompt) {
        context.prompt = window.generateAIPrompt(action, 'brainstorm', context);
      }

      window.BridgeClient.sendAndWait(action, conceptId, 'brainstorm', context, progress => {
        console.log('AI request progress:', progress.elapsed + 'ms');
      }).then(response => {
        delete state.pendingAIRequests[conceptId];
        hideNodeLoadingOverlay(conceptId);

        // Store response as annotation
        if (!state.annotations[conceptId]) state.annotations[conceptId] = [];
        state.annotations[conceptId].unshift({
          type: 'ai',
          action: action,
          text: response.content,
          timestamp: Date.now(),
          collapsed: false
        });
        saveState();

        // Show in response panel with markdown (parseMarkdown escapes HTML for XSS safety)
        document.getElementById('ai-response-title').textContent = 'AI: ' + action + ' - ' + concept.name;
        const contentEl = document.getElementById('ai-response-content');
        contentEl.classList.add('markdown');
        // parseMarkdown escapes all HTML before processing, safe to use innerHTML
        contentEl.innerHTML = parseMarkdown(response.content);
        aiResponsePanel.classList.add('visible');

        // Update sidebar to show annotation badge
        renderSidebar();
        draw();
      }).catch(err => {
        delete state.pendingAIRequests[conceptId];
        hideNodeLoadingOverlay(conceptId);
        draw();
        console.error('AI action failed:', err);
        alert('AI request failed: ' + err.message);
      });
    }
    // ============ END AI BRIDGE INTEGRATION ============

    window.addEventListener('resize', resizeCanvas);
    const wasLoaded = loadState();
    zoom.load(); // Load saved zoom level

    // Initialize bridge client
    initBridgeClient();

    // Set header title from config
    document.getElementById('header-title').textContent = PROJECT_NAME + ' - Brainstorm Explorer';
    document.title = PROJECT_NAME + ' - Brainstorm Explorer';

    initPresetButtons();
    initTopicSelect();
    resizeCanvas();
    renderSidebar();
    renderIdeas();
    if (wasLoaded) console.log('Restored saved state from localStorage');
    })(); // End init
  </script>
</body>
</html>
