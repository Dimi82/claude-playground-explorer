<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Architecture Explorer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0d1117; color: #c9d1d9; min-height: 100vh; display: flex; flex-direction: column;
    }
    header {
      background: #161b22; border-bottom: 1px solid #30363d; padding: 16px 24px;
      display: flex; align-items: center; justify-content: space-between;
    }
    header h1 { font-size: 20px; font-weight: 600; color: #f0f6fc; }
    .header-actions { display: flex; gap: 8px; }
    .header-btn {
      background: #21262d; border: 1px solid #30363d; border-radius: 6px;
      padding: 6px 12px; color: #c9d1d9; font-size: 12px; cursor: pointer;
    }
    .header-btn:hover { background: #30363d; }
    .header-btn.active { background: #238636; border-color: #238636; color: white; }
    .main-container { display: flex; flex: 1; overflow: hidden; }

    /* Left Panel */
    .component-tree {
      width: 280px; background: #161b22; border-right: 1px solid #30363d;
      overflow-y: auto; padding: 16px 0;
    }
    .tree-section { margin-bottom: 8px; }
    .tree-section-header {
      padding: 8px 16px; font-size: 11px; font-weight: 600;
      text-transform: uppercase; color: #8b949e; letter-spacing: 0.5px;
    }
    .tree-item {
      padding: 8px 16px 8px 24px; cursor: pointer; display: flex;
      align-items: center; gap: 8px; transition: background 0.15s; font-size: 13px;
      position: relative;
    }
    .tree-item:hover { background: #21262d; }
    .tree-item.active { background: #388bfd26; color: #58a6ff; border-left: 2px solid #58a6ff; padding-left: 22px; }
    .tree-item.has-annotation::after {
      content: ''; position: absolute; right: 12px; top: 50%; transform: translateY(-50%);
      width: 8px; height: 8px; border-radius: 50%; background: #f0883e;
    }
    .tree-item.loading::before {
      content: ''; position: absolute; right: 24px; top: 50%; transform: translateY(-50%);
      width: 12px; height: 12px; border: 2px solid #30363d; border-top-color: #58a6ff;
      border-radius: 50%; animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: translateY(-50%) rotate(360deg); } }
    .tree-item .icon {
      width: 16px; height: 16px; border-radius: 3px; display: flex;
      align-items: center; justify-content: center; font-size: 10px; font-weight: bold;
    }
    .icon-node { background: #238636; color: white; }
    .icon-llm { background: #a371f7; color: white; }
    .icon-tool { background: #f0883e; color: white; }
    .icon-state { background: #3fb950; color: white; }
    .icon-entry { background: #58a6ff; color: white; }

    /* Center Panel */
    .diagram-panel { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
    .diagram-header {
      background: #161b22; border-bottom: 1px solid #30363d; padding: 12px 24px;
      display: flex; align-items: center; justify-content: space-between;
    }
    .view-tabs { display: flex; gap: 4px; }
    .view-tab {
      padding: 6px 12px; background: transparent; border: 1px solid #30363d;
      border-radius: 6px; color: #8b949e; cursor: pointer; font-size: 12px;
    }
    .view-tab:hover { background: #21262d; color: #c9d1d9; }
    .view-tab.active { background: #21262d; color: #f0f6fc; border-color: #58a6ff; }
    .diagram-canvas { flex: 1; position: relative; overflow: auto; padding: 40px; }

    /* Workflow Diagram */
    .workflow-diagram { display: flex; flex-direction: column; align-items: flex-end; gap: 20px; min-width: 800px; padding-right: 80px; }
    .phase-row { display: flex; align-items: center; gap: 24px; }
    .workflow-below-phase3 { display: flex; flex-direction: column; align-items: center; gap: 20px; }
    .node-box {
      background: #21262d; border: 2px solid #30363d; border-radius: 8px;
      padding: 16px 20px; min-width: 180px; cursor: pointer; transition: all 0.2s;
      text-align: center; position: relative;
    }
    .node-box:hover { border-color: #58a6ff; transform: translateY(-2px); }
    .node-box.selected { border-color: #58a6ff; background: #388bfd26; }
    .node-box.has-annotation { box-shadow: 0 0 0 3px #f0883e40; }
    .node-box.phase-1 { border-left: 4px solid #58a6ff; }
    .node-box.phase-2 { border-left: 4px solid #a371f7; }
    .node-box.phase-3 { border-left: 4px solid #3fb950; }
    .node-box.phase-4 { border-left: 4px solid #f0883e; }
    .node-title { font-weight: 600; font-size: 14px; margin-bottom: 4px; }
    .node-subtitle { font-size: 11px; color: #8b949e; }
    .annotation-badge {
      position: absolute; top: -8px; right: -8px; width: 20px; height: 20px;
      background: #f0883e; border-radius: 50%; display: flex; align-items: center;
      justify-content: center; font-size: 10px; font-weight: bold; color: white;
    }
    .arrow { color: #484f58; font-size: 24px; cursor: pointer; padding: 4px; border-radius: 4px; }
    .arrow:hover { background: #21262d; }
    .arrow.has-annotation { color: #f0883e; }
    .arrow-down { margin: 8px 0; }
    .conditional-box {
      background: #161b22; border: 2px dashed #30363d; border-radius: 8px;
      padding: 12px 16px; font-size: 12px; color: #8b949e; cursor: pointer;
    }
    .conditional-box:hover { border-color: #58a6ff; }
    .conditional-box.has-annotation { border-color: #f0883e; }
    .branch-container { display: flex; gap: 60px; align-items: flex-start; }
    .branch { display: flex; flex-direction: column; align-items: center; gap: 16px; }
    .branch-label { font-size: 11px; color: #8b949e; padding: 4px 8px; background: #21262d; border-radius: 4px; }

    /* Data Flow */
    .data-flow-diagram { display: flex; flex-direction: column; gap: 32px; padding: 20px; }
    .flow-layer { display: flex; align-items: center; gap: 24px; }
    .flow-layer-label { width: 120px; font-size: 11px; font-weight: 600; text-transform: uppercase; color: #8b949e; text-align: right; }
    .flow-boxes { display: flex; gap: 16px; flex-wrap: wrap; }
    .flow-box {
      background: #21262d; border: 1px solid #30363d; border-radius: 6px;
      padding: 12px 16px; font-size: 12px; cursor: pointer; position: relative;
    }
    .flow-box:hover { border-color: #58a6ff; }
    .flow-box.selected { border-color: #58a6ff; background: #388bfd26; }
    .flow-box.has-annotation { box-shadow: 0 0 0 2px #f0883e40; }

    /* File Tree */
    .file-tree { font-family: 'SF Mono', Monaco, monospace; font-size: 13px; padding: 20px; }
    .file-entry { padding: 4px 0; cursor: pointer; display: flex; align-items: center; gap: 8px; position: relative; }
    .file-entry:hover { color: #58a6ff; }
    .file-entry.selected { color: #58a6ff; }
    .file-entry.has-annotation::after {
      content: ''; position: absolute; right: 0; width: 8px; height: 8px;
      border-radius: 50%; background: #f0883e;
    }
    .file-indent { color: #484f58; }
    .file-icon { width: 16px; text-align: center; }

    /* Sequence Diagram */
    .sequence-diagram { padding: 40px; display: flex; flex-direction: column; gap: 60px; }
    .sequence-flow { display: flex; flex-direction: column; min-width: 800px; }
    .sequence-flow-title { font-size: 14px; font-weight: 600; color: #f0f6fc; margin-bottom: 20px; padding-bottom: 12px; border-bottom: 1px solid #30363d; }
    .participant-header { display: grid; gap: 40px; margin-bottom: 0; position: relative; z-index: 2; }
    .participant-box {
      background: #21262d; border: 2px solid #30363d; border-radius: 8px;
      padding: 12px 16px; text-align: center; font-weight: 600; font-size: 13px;
      position: relative;
    }
    .participant-box::after {
      content: ''; position: absolute; bottom: -20px; left: 50%;
      transform: translateX(-50%); width: 2px; height: 20px; background: #30363d;
    }
    .sequence-timeline { display: grid; gap: 40px; position: relative; min-height: 100px; }
    .lifeline-column { display: flex; flex-direction: column; align-items: center; position: relative; }
    .lifeline { width: 2px; background: #30363d; position: absolute; top: 0; bottom: 0; left: 50%; transform: translateX(-50%); }
    .messages-layer { position: absolute; top: 20px; left: 0; right: 0; display: flex; flex-direction: column; gap: 24px; z-index: 1; }
    .message-row { display: grid; gap: 40px; align-items: center; min-height: 40px; }
    .message-arrow {
      position: relative; display: flex; align-items: center; justify-content: center;
      cursor: pointer; padding: 4px 0; transition: all 0.2s; min-height: 32px;
    }
    .message-arrow::before {
      content: ''; position: absolute; height: 2px; background: #58a6ff;
      left: 20px; right: 20px; top: 50%;
    }
    .message-arrow::after {
      content: ''; position: absolute; right: 12px; top: 50%; transform: translateY(-50%);
      border: 6px solid transparent; border-left: 8px solid #58a6ff;
    }
    .message-arrow.reverse::after {
      right: auto; left: 12px;
      border-left: none; border-right: 8px solid #58a6ff;
    }
    .message-arrow.return::before { background: #8b949e; height: 0; border-top: 2px dashed #8b949e; }
    .message-arrow.return::after { border-left-color: #8b949e; }
    .message-arrow.return.reverse::after { border-right-color: #8b949e; border-left-color: transparent; }
    .message-arrow.async::before { background: #a371f7; }
    .message-arrow.async::after { border-left-color: #a371f7; }
    .message-arrow.async.reverse::after { border-right-color: #a371f7; border-left-color: transparent; }
    .message-arrow.self-call {
      justify-content: flex-end; padding-right: 20px; min-height: 50px;
    }
    .message-arrow.self-call::before {
      left: 50%; right: -30px; top: 0; height: 100%;
      background: none; border: 2px solid #58a6ff; border-left: none;
      border-radius: 0 8px 8px 0;
    }
    .message-arrow.self-call::after {
      right: auto; left: calc(50% - 8px); top: auto; bottom: -2px;
      transform: rotate(90deg);
    }
    .message-label {
      background: #0d1117; padding: 4px 12px; border-radius: 4px;
      font-size: 12px; color: #c9d1d9; z-index: 1; position: relative;
      white-space: nowrap; border: 1px solid #30363d; max-width: 200px;
      overflow: hidden; text-overflow: ellipsis;
    }
    .message-arrow:hover { transform: translateY(-2px); }
    .message-arrow:hover .message-label { background: #161b22; border-color: #58a6ff; }
    .message-arrow.selected::before { background: #58a6ff; box-shadow: 0 0 8px #58a6ff80; }
    .message-arrow.selected .message-label { background: #388bfd26; border-color: #58a6ff; color: #58a6ff; }
    .message-arrow.has-annotation .message-label::after {
      content: ''; position: absolute; right: -6px; top: -6px;
      width: 12px; height: 12px; background: #f0883e; border-radius: 50%; border: 2px solid #0d1117;
    }
    .sequence-fragment {
      border: 2px dashed #30363d; border-radius: 8px; padding: 16px;
      margin: 8px 0; background: #161b2210; position: relative;
    }
    .fragment-label {
      position: absolute; top: -10px; left: 12px; background: #0d1117;
      padding: 2px 8px; font-size: 10px; font-weight: 600;
      text-transform: uppercase; color: #8b949e; border: 1px solid #30363d; border-radius: 4px;
    }
    .sequence-fragment.loop { border-color: #3fb950; }
    .sequence-fragment.loop .fragment-label { color: #3fb950; border-color: #3fb950; }
    .sequence-fragment.alt { border-color: #f0883e; }
    .sequence-fragment.alt .fragment-label { color: #f0883e; border-color: #f0883e; }
    .sequence-fragment.opt { border-color: #a371f7; }
    .sequence-fragment.opt .fragment-label { color: #a371f7; border-color: #a371f7; }

    /* Right Panel */
    .details-panel { width: 420px; background: #161b22; border-left: 1px solid #30363d; display: flex; flex-direction: column; }
    .details-header { padding: 16px 20px; border-bottom: 1px solid #30363d; display: flex; align-items: center; justify-content: space-between; }
    .details-title { font-weight: 600; font-size: 16px; }
    .details-badge { font-size: 10px; padding: 3px 8px; border-radius: 12px; font-weight: 600; text-transform: uppercase; }
    .badge-node { background: #238636; color: white; }
    .badge-llm { background: #a371f7; color: white; }
    .badge-tool { background: #f0883e; color: white; }
    .badge-state { background: #3fb950; color: white; }
    .badge-entry { background: #58a6ff; color: white; }
    .details-content { flex: 1; overflow-y: auto; padding: 20px; }
    .detail-section { margin-bottom: 24px; }
    .detail-section-title { font-size: 11px; font-weight: 600; text-transform: uppercase; color: #8b949e; margin-bottom: 12px; letter-spacing: 0.5px; }
    .detail-text { font-size: 13px; line-height: 1.6; color: #c9d1d9; }
    .detail-code { background: #0d1117; border: 1px solid #30363d; border-radius: 6px; padding: 12px; font-family: 'SF Mono', Monaco, monospace; font-size: 12px; overflow-x: auto; white-space: pre; }
    .detail-list { list-style: none; }
    .detail-list li { padding: 6px 0; font-size: 13px; display: flex; align-items: flex-start; gap: 8px; }
    .detail-list li::before { content: '\2022'; color: #58a6ff; }
    .detail-file { font-family: 'SF Mono', Monaco, monospace; font-size: 12px; color: #58a6ff; padding: 8px 12px; background: #0d1117; border-radius: 4px; margin-bottom: 8px; display: inline-block; }

    /* Annotations Section */
    .annotations-section { background: #0d1117; border-radius: 8px; padding: 16px; margin-bottom: 16px; }
    .annotation-item { background: #161b22; border: 1px solid #30363d; border-radius: 6px; padding: 12px; margin-bottom: 8px; }
    .annotation-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
    .annotation-type { font-size: 10px; padding: 2px 8px; border-radius: 10px; font-weight: 600; text-transform: uppercase; }
    .annotation-type.question { background: #388bfd40; color: #58a6ff; }
    .annotation-type.comment { background: #3fb95040; color: #3fb950; }
    .annotation-type.edit { background: #f0883e40; color: #f0883e; }
    .annotation-delete { background: none; border: none; color: #f85149; cursor: pointer; font-size: 14px; }
    .annotation-text { font-size: 13px; line-height: 1.5; margin-bottom: 8px; }
    .annotation-prompt {
      background: #0d1117; border: 1px solid #30363d; border-radius: 4px;
      padding: 10px; font-family: 'SF Mono', Monaco, monospace; font-size: 11px;
      line-height: 1.4; color: #8b949e; white-space: pre-wrap; margin-top: 8px;
    }
    .annotation-prompt-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px; }
    .annotation-prompt-label { font-size: 10px; color: #6e7681; text-transform: uppercase; }
    .annotation-copy-btn {
      background: #21262d; border: 1px solid #30363d; border-radius: 4px;
      padding: 3px 8px; font-size: 10px; color: #8b949e; cursor: pointer;
    }
    .annotation-copy-btn:hover { background: #30363d; color: #c9d1d9; }
    .annotation-copy-btn.copied { background: #238636; border-color: #238636; color: white; }
    .add-annotation-btn {
      width: 100%; padding: 10px; background: #21262d; border: 1px dashed #30363d;
      border-radius: 6px; color: #8b949e; font-size: 12px; cursor: pointer; margin-top: 8px;
    }
    .add-annotation-btn:hover { background: #30363d; color: #c9d1d9; border-style: solid; }

    /* Question Panel */
    .question-panel { border-top: 1px solid #30363d; padding: 16px 20px; background: #0d1117; }
    .question-input-container { display: flex; gap: 8px; }
    .question-input { flex: 1; background: #161b22; border: 1px solid #30363d; border-radius: 6px; padding: 10px 14px; color: #c9d1d9; font-size: 13px; outline: none; }
    .question-input:focus { border-color: #58a6ff; }
    .question-input::placeholder { color: #484f58; }
    .question-btn { background: #238636; border: none; border-radius: 6px; padding: 10px 16px; color: white; font-size: 13px; font-weight: 500; cursor: pointer; }
    .question-btn:hover { background: #2ea043; }

    /* Context Menu */
    .context-menu {
      position: fixed; background: #161b22; border: 1px solid #30363d; border-radius: 8px;
      padding: 8px 0; min-width: 180px; z-index: 1000; box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      display: none;
    }
    .context-menu.visible { display: block; }
    .context-menu-item { padding: 8px 16px; font-size: 13px; cursor: pointer; display: flex; align-items: center; gap: 10px; }
    .context-menu-item:hover { background: #21262d; }
    .context-menu-item .icon { font-size: 14px; }
    .context-menu-divider { height: 1px; background: #30363d; margin: 4px 0; }

    /* Annotation Modal */
    .modal-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.6); z-index: 1001; display: none;
      align-items: center; justify-content: center;
    }
    .modal-overlay.visible { display: flex; }
    .modal {
      background: #161b22; border: 1px solid #30363d; border-radius: 12px;
      padding: 24px; width: 400px; max-width: 90%;
    }
    .modal-title { font-size: 18px; font-weight: 600; margin-bottom: 16px; }
    .modal-field { margin-bottom: 16px; }
    .modal-label { font-size: 12px; color: #8b949e; margin-bottom: 6px; display: block; }
    .modal-select, .modal-textarea {
      width: 100%; background: #0d1117; border: 1px solid #30363d; border-radius: 6px;
      padding: 10px 12px; color: #c9d1d9; font-size: 13px;
    }
    .modal-textarea { min-height: 100px; resize: vertical; font-family: inherit; }
    .modal-actions { display: flex; gap: 8px; justify-content: flex-end; }
    .modal-btn { padding: 8px 16px; border-radius: 6px; font-size: 13px; cursor: pointer; border: none; }
    .modal-btn.primary { background: #238636; color: white; }
    .modal-btn.secondary { background: #21262d; color: #c9d1d9; border: 1px solid #30363d; }
    .modal-btn:hover { opacity: 0.9; }

    /* Annotations Summary Panel */
    .annotations-summary { background: #161b22; border-bottom: 1px solid #30363d; padding: 12px 20px; display: none; }
    .annotations-summary.visible { display: block; }
    .annotations-summary-title { font-size: 11px; font-weight: 600; text-transform: uppercase; color: #8b949e; margin-bottom: 8px; }
    .annotations-stats { display: flex; gap: 16px; }
    .stat-item { display: flex; align-items: center; gap: 6px; font-size: 12px; }
    .stat-dot { width: 8px; height: 8px; border-radius: 50%; }
    .stat-dot.question { background: #58a6ff; }
    .stat-dot.comment { background: #3fb950; }
    .stat-dot.edit { background: #f0883e; }

    /* ========== Enhanced Workflow Diagram (V2) ========== */
    .workflow-diagram-v2 {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 60px;
      padding: 60px 40px;
      min-width: 900px;
      position: relative;
    }

    .workflow-layer {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      gap: 80px;
      width: 100%;
      position: relative;
      z-index: 2;
      min-height: 80px;
    }

    .workflow-node {
      cursor: pointer;
      transition: all 0.2s;
      position: relative;
    }

    .workflow-node:hover { transform: translateY(-2px); }
    .workflow-node.selected { box-shadow: 0 0 0 3px #58a6ff; }
    .workflow-node.has-annotation::after {
      content: attr(data-annotation-count);
      position: absolute;
      top: -8px;
      right: -8px;
      width: 20px;
      height: 20px;
      background: #f0883e;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: bold;
      color: white;
    }

    .workflow-node-start,
    .workflow-node-end {
      width: 140px;
      height: 70px;
      border-radius: 35px;
      background: #21262d;
      border: 3px solid #30363d;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 14px;
      color: #c9d1d9;
    }

    .workflow-node-start { border-color: #3fb950; background: #3fb95015; }
    .workflow-node-end { border-color: #f85149; background: #f8514915; }

    .workflow-node-process {
      min-width: 180px;
      max-width: 220px;
      background: #21262d;
      border: 2px solid #30363d;
      border-radius: 8px;
      padding: 16px 20px;
    }

    .workflow-node-process.phase-1 { border-left: 4px solid #58a6ff; }
    .workflow-node-process.phase-2 { border-left: 4px solid #a371f7; }
    .workflow-node-process.phase-3 { border-left: 4px solid #3fb950; }
    .workflow-node-process.phase-4 { border-left: 4px solid #f0883e; }

    .workflow-node-title {
      font-weight: 600;
      font-size: 14px;
      margin-bottom: 4px;
      color: #f0f6fc;
    }

    .workflow-node-subtitle {
      font-size: 11px;
      color: #8b949e;
    }

    .workflow-node-decision {
      width: 120px;
      height: 120px;
      background: #161b22;
      border: 3px solid #f0883e;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      transform: rotate(45deg);
    }

    .workflow-node-decision .decision-content {
      transform: rotate(-45deg);
      text-align: center;
      padding: 10px;
      font-size: 12px;
      font-weight: 600;
      color: #f0883e;
      max-width: 80px;
      line-height: 1.3;
    }

    .workflow-node-merge {
      width: 40px;
      height: 40px;
      background: #21262d;
      border: 3px solid #8b949e;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #8b949e;
      font-size: 16px;
    }

    .workflow-edges {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      pointer-events: none;
      overflow: visible;
    }

    .workflow-edge {
      stroke: #58a6ff;
      stroke-width: 2;
      fill: none;
      transition: stroke 0.2s;
    }

    .workflow-edge.loop {
      stroke: #a371f7;
      stroke-dasharray: 6, 4;
    }

    .workflow-edge.secondary {
      stroke: #8b949e;
    }

    .workflow-edge-label {
      font-size: 11px;
      fill: #8b949e;
      font-weight: 600;
    }

    /* Zoom Controls */
    .zoom-controls {
      position: sticky; bottom: 16px; left: calc(100% - 250px); width: fit-content;
      display: flex; gap: 4px; margin-top: auto;
      background: #161b22; border: 1px solid #30363d; border-radius: 8px;
      padding: 8px; z-index: 100; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    .zoom-btn {
      background: #21262d; border: 1px solid #30363d; border-radius: 4px;
      color: #c9d1d9; width: 32px; height: 32px; cursor: pointer; font-size: 16px;
      display: flex; align-items: center; justify-content: center; transition: all 0.15s;
    }
    .zoom-btn:hover { background: #30363d; }
    .zoom-btn:active { transform: scale(0.95); }
    .zoom-btn.zoom-text { width: auto; padding: 0 10px; font-size: 11px; }
    .zoom-level {
      color: #8b949e; font-size: 11px; display: flex; align-items: center;
      padding: 0 8px; min-width: 45px; justify-content: center;
    }
    .diagram-content {
      transform-origin: 0 0;
      display: inline-block;
      min-width: 100%;
    }

    /* ========== AI Bridge Integration ========== */
    .bridge-status {
      position: fixed; top: 12px; left: 50%; transform: translateX(-50%); display: flex; align-items: center;
      gap: 6px; padding: 6px 12px; border-radius: 6px; font-size: 11px;
      background: #21262d; border: 1px solid #30363d; z-index: 200;
    }
    .bridge-status .status-dot {
      width: 8px; height: 8px; border-radius: 50%; transition: background 0.3s;
    }
    .bridge-status.connected .status-dot { background: #3fb950; }
    .bridge-status.disconnected .status-dot { background: #f85149; }
    .bridge-status.connecting .status-dot { background: #f0883e; animation: pulse 1s infinite; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

    .ai-actions-menu {
      position: absolute; background: #161b22; border: 1px solid #30363d;
      border-radius: 8px; padding: 8px; z-index: 300; min-width: 180px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4); display: none;
    }
    .ai-actions-menu.visible { display: block; }
    .ai-action-item {
      display: flex; align-items: center; gap: 10px; padding: 8px 12px;
      border-radius: 6px; cursor: pointer; font-size: 12px; transition: background 0.15s;
    }
    .ai-action-item:hover { background: #21262d; }
    .ai-action-item .icon { font-size: 14px; }
    .ai-action-item .label { flex: 1; }
    .ai-action-item .desc { font-size: 10px; color: #8b949e; }
    .ai-action-item.disabled { opacity: 0.5; cursor: not-allowed; }

    .node-loading {
      position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(22, 27, 34, 0.9); display: flex; flex-direction: column;
      align-items: center; justify-content: center; border-radius: 6px; gap: 8px;
    }
    .node-loading .spinner {
      width: 20px; height: 20px; border: 2px solid #30363d;
      border-top-color: #58a6ff; border-radius: 50%; animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .node-loading .text { font-size: 11px; color: #8b949e; }

    /* AI Annotation styling */
    .annotation-item.ai-annotation { border-left: 3px solid #a371f7; }
    .annotation-type.ai { background: #a371f7; }
    .annotation-ai-badge {
      display: inline-flex; align-items: center; gap: 4px;
      font-size: 10px; color: #a371f7; margin-left: 8px;
    }
    .annotation-collapsed { max-height: 60px; overflow: hidden; position: relative; }
    .annotation-collapsed::after {
      content: ''; position: absolute; bottom: 0; left: 0; right: 0;
      height: 30px; background: linear-gradient(transparent, #21262d);
    }
    .annotation-expand-btn {
      background: transparent; border: 1px solid #30363d; border-radius: 4px;
      color: #8b949e; padding: 4px 8px; font-size: 10px; cursor: pointer; margin-top: 4px;
    }
    .annotation-expand-btn:hover { background: #21262d; color: #c9d1d9; }

    /* Markdown rendering styles for AI responses */
    .annotation-text.markdown h2 { font-size: 14px; font-weight: 600; color: #f0f6fc; margin: 12px 0 8px 0; padding-bottom: 4px; border-bottom: 1px solid #30363d; }
    .annotation-text.markdown h3 { font-size: 13px; font-weight: 600; color: #e6edf3; margin: 10px 0 6px 0; }
    .annotation-text.markdown h4 { font-size: 12px; font-weight: 600; color: #c9d1d9; margin: 8px 0 4px 0; }
    .annotation-text.markdown p { margin: 6px 0; }
    .annotation-text.markdown ul, .annotation-text.markdown ol { margin: 6px 0; padding-left: 20px; }
    .annotation-text.markdown li { margin: 3px 0; }
    .annotation-text.markdown code { background: #0d1117; padding: 2px 6px; border-radius: 4px; font-family: 'SF Mono', Monaco, monospace; font-size: 11px; color: #f0883e; }
    .annotation-text.markdown pre { background: #0d1117; border: 1px solid #30363d; border-radius: 6px; padding: 12px; margin: 8px 0; overflow-x: auto; }
    .annotation-text.markdown pre code { background: none; padding: 0; color: #c9d1d9; display: block; white-space: pre; }
    .annotation-text.markdown strong { color: #f0f6fc; font-weight: 600; }
    .annotation-text.markdown em { font-style: italic; color: #8b949e; }
  </style>
</head>
<body>
  <header>
    <h1 id="header-title">Architecture Explorer</h1>
    <div class="header-actions">
      <button class="header-btn" id="export-btn">Export Annotations</button>
      <button class="header-btn" id="reset-btn">Reset All</button>
      <button class="header-btn" id="clear-btn">Clear Annotations</button>
    </div>
  </header>

  <!-- AI Bridge Status Indicator -->
  <div id="bridge-status" class="bridge-status disconnected">
    <span class="status-dot"></span>
    <span class="status-text">AI Disconnected</span>
  </div>

  <!-- AI Actions Menu (positioned dynamically) -->
  <div id="ai-actions-menu" class="ai-actions-menu">
    <!-- Populated dynamically based on graph type -->
  </div>

  <div class="annotations-summary" id="annotations-summary">
    <div class="annotations-summary-title">Annotations</div>
    <div class="annotations-stats" id="annotations-stats"></div>
  </div>

  <div class="main-container">
    <div class="component-tree" id="component-tree"></div>
    <div class="diagram-panel">
      <div class="diagram-header">
        <div class="view-tabs">
          <button class="view-tab active" data-view="workflow">Workflow</button>
          <button class="view-tab" data-view="dataflow">Data Flow</button>
          <button class="view-tab" data-view="sequence">Sequence</button>
          <button class="view-tab" data-view="files">File Structure</button>
        </div>
        <div style="font-size: 11px; color: #8b949e;">Right-click to annotate</div>
      </div>
      <div class="diagram-canvas" id="diagram-canvas">
        <div class="diagram-content" id="diagram-content"></div>
        <div class="zoom-controls">
          <button class="zoom-btn" id="zoom-out" title="Zoom Out (Ctrl+-)">âˆ’</button>
          <div class="zoom-level" id="zoom-level">100%</div>
          <button class="zoom-btn" id="zoom-in" title="Zoom In (Ctrl++)">+</button>
          <button class="zoom-btn zoom-text" id="zoom-reset" title="Reset to 100% (Ctrl+0)">Reset</button>
          <button class="zoom-btn zoom-text" id="zoom-fit" title="Fit to View">Fit</button>
        </div>
      </div>
    </div>
    <div class="details-panel">
      <div class="details-header">
        <span class="details-title" id="detail-title">Select a component</span>
        <span class="details-badge badge-node" id="detail-badge" style="display: none;">NODE</span>
      </div>
      <div class="details-content" id="detail-content"></div>
      <div class="question-panel">
        <div class="question-input-container">
          <input type="text" class="question-input" id="question-input" placeholder="Ask about the architecture...">
          <button class="question-btn" id="ask-btn">Ask</button>
        </div>
      </div>
    </div>
  </div>

  <div class="context-menu" id="context-menu">
    <div class="context-menu-item ai-action" data-ai-action="explain"><span class="icon">ðŸ“–</span> AI: Explain</div>
    <div class="context-menu-item ai-action" data-ai-action="dependencies"><span class="icon">ðŸ”€</span> AI: Dependencies</div>
    <div class="context-menu-item ai-action" data-ai-action="improve"><span class="icon">âœ¨</span> AI: Improvements</div>
    <div class="context-menu-item ai-action" data-ai-action="security"><span class="icon">ðŸ”’</span> AI: Security</div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" data-action="question"><span class="icon">?</span> Add Question</div>
    <div class="context-menu-item" data-action="comment"><span class="icon">C</span> Add Comment</div>
    <div class="context-menu-item" data-action="edit"><span class="icon">E</span> Mark for Edit</div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item ai-action" data-ai-action="modify-graph"><span class="icon">ðŸ”€</span> AI: Modify Graph</div>
    <div class="context-menu-divider"></div>
    <div class="context-menu-item" data-action="view"><span class="icon">V</span> View Details</div>
  </div>

  <div class="modal-overlay" id="modal-overlay">
    <div class="modal">
      <div class="modal-title" id="modal-title">Add Annotation</div>
      <div class="modal-field">
        <label class="modal-label">Type</label>
        <select class="modal-select" id="annotation-type">
          <option value="question">Question</option>
          <option value="comment">Comment</option>
          <option value="edit">Edit Suggestion</option>
        </select>
      </div>
      <div class="modal-field">
        <label class="modal-label">Your annotation</label>
        <textarea class="modal-textarea" id="annotation-text" placeholder="Enter your question, comment, or edit suggestion..."></textarea>
      </div>
      <div class="modal-actions">
        <button class="modal-btn secondary" id="modal-cancel">Cancel</button>
        <button class="modal-btn primary" id="modal-save">Save</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="graph-modify-modal">
    <div class="modal">
      <div class="modal-title" id="graph-modify-title">AI: Modify Graph</div>
      <div class="modal-field">
        <label class="modal-label">Describe what changes you'd like the AI to make to the graph structure</label>
        <textarea class="modal-textarea" id="graph-modify-text" placeholder="Example: Add related security components, Connect this to the authentication flow, Remove outdated nodes..."></textarea>
      </div>
      <div class="modal-actions">
        <button class="modal-btn secondary" id="graph-modify-cancel">Cancel</button>
        <button class="modal-btn primary" id="graph-modify-send">Generate Changes</button>
      </div>
    </div>
  </div>

  <!-- External config: include before main script -->
  <!-- Example: <script src="config-myproject.js"></script> -->
  <!-- The config.js file should define: window.EXTERNAL_CONFIG = { projectName: "...", ... }; -->

  <!-- Sample config for testing (remove in production) -->
  <script src="sample-config.js" onerror="console.log('No sample-config.js found, expecting external config')"></script>

  <!-- Bridge Client for AI Connectivity (inlined for self-contained templates) -->
  <script>
(function() {
  'use strict';

  const BridgeClient = {
    baseUrl: 'http://localhost:4242',
    _connected: false,
    _onStatusChange: null,

    async checkConnection() {
      try {
        const response = await fetch(this.baseUrl + '/status');
        const ok = response.ok;
        this._setConnected(ok);
        return ok;
      } catch (e) {
        this._setConnected(false);
        return false;
      }
    },

    /**
     * Send action and wait for Claude's response.
     * The server holds the connection until Claude responds.
     */
    async sendAndWait(action, nodeId, graphType, context) {
      const response = await fetch(this.baseUrl + '/prompt', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ action, nodeId, graphType, context })
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error || 'Request failed');
      }

      return response.json();
    },

    _setConnected(connected) {
      const changed = this._connected !== connected;
      this._connected = connected;
      if (changed && this._onStatusChange) {
        this._onStatusChange(connected);
      }
    },

    onStatusChange(callback) {
      this._onStatusChange = callback;
    },

    isConnected() {
      return this._connected;
    },

    startConnectionMonitor(interval = 10000) {
      this.checkConnection();
      setInterval(() => this.checkConnection(), interval);
    }
  };

  // AI prompt generator
  function generateAIPrompt(action, graphType, context) {
    const { nodeTitle, nodeDescription, projectName, file } = context;

    if (graphType === 'architecture') {
      switch (action) {
        case 'explain':
          return `Explain what ${nodeTitle} does.${file ? ' File: ' + file : ''}${nodeDescription ? '\n' + nodeDescription : ''}\nProject: ${projectName}`;
        case 'dependencies':
          return `What are the dependencies of ${nodeTitle}?${file ? ' File: ' + file : ''}\nProject: ${projectName}`;
        case 'improve':
          return `Suggest improvements for ${nodeTitle}.${file ? ' File: ' + file : ''}\nProject: ${projectName}`;
        case 'security':
          return `Security concerns for ${nodeTitle}?${file ? ' File: ' + file : ''}\nProject: ${projectName}`;
      }
    }
    return `Analyze "${nodeTitle}" in ${projectName}.`;
  }

  window.BridgeClient = BridgeClient;
  window.generateAIPrompt = generateAIPrompt;
})();
  </script>

  <script>
    // ============ CONFIGURATION LOADER ============
    (function init() {
      // Load config: prefer external window.EXTERNAL_CONFIG, fall back to inline
      function loadConfig() {
        // Check for externally loaded config (via <script src="config.js">)
        if (window.EXTERNAL_CONFIG) {
          return window.EXTERNAL_CONFIG;
        }

        // No external config and no inline config - show error
        alert('No configuration found. Either:\n1. Include a config script: <script src="config-name.js">\n2. Replace {{CONFIG_JSON}} with inline config');
        throw new Error('No configuration found');
      }

      const CONFIG = loadConfig();
    // ============ END CONFIGURATION LOADER ============

    const PROJECT_NAME = CONFIG.projectName;
    const INITIAL_COMPONENT_DATA = CONFIG.componentData;
    const INITIAL_TREE_STRUCTURE = CONFIG.treeStructure;
    const DATA_FLOW_LAYERS = CONFIG.dataFlowLayers;
    const FILE_TREE_ENTRIES = CONFIG.fileTreeEntries;
    const WORKFLOW_STRUCTURE = CONFIG.workflowStructure || [];
    const SEQUENCE_FLOWS = CONFIG.sequenceFlows || [];

    const STORAGE_KEY = 'architecture-explorer-' + PROJECT_NAME.toLowerCase().replace(/\s+/g, '-');

    const state = {
      componentData: { ...INITIAL_COMPONENT_DATA },
      treeStructure: JSON.parse(JSON.stringify(INITIAL_TREE_STRUCTURE)),
      workflowStructure: CONFIG.workflowStructureV2 ? JSON.parse(JSON.stringify(CONFIG.workflowStructureV2)) : null,
      dataFlowLayers: DATA_FLOW_LAYERS ? JSON.parse(JSON.stringify(DATA_FLOW_LAYERS)) : [],
      sequenceFlows: SEQUENCE_FLOWS ? JSON.parse(JSON.stringify(SEQUENCE_FLOWS)) : [],
      selectedComponent: null,
      currentView: 'workflow',
      annotations: {},
      contextTarget: null,
      pendingAIRequests: {}  // Track pending AI requests by nodeId
    };

    // ============ ZOOM MANAGEMENT ============
    const zoom = {
      scale: 1.0,
      minScale: 0.25,
      maxScale: 2.0,
      step: 0.1,

      apply: function() {
        var content = document.getElementById('diagram-content');
        if (content) {
          content.style.transform = 'scale(' + this.scale + ')';
        }
        var levelDisplay = document.getElementById('zoom-level');
        if (levelDisplay) {
          levelDisplay.textContent = Math.round(this.scale * 100) + '%';
        }
      },

      zoomIn: function() {
        this.scale = Math.min(this.maxScale, Math.round((this.scale + this.step) * 100) / 100);
        this.apply();
        this.save();
      },

      zoomOut: function() {
        this.scale = Math.max(this.minScale, Math.round((this.scale - this.step) * 100) / 100);
        this.apply();
        this.save();
      },

      reset: function() {
        this.scale = 1.0;
        this.apply();
        this.save();
        // Reset scroll position
        var canvas = document.getElementById('diagram-canvas');
        if (canvas) { canvas.scrollTop = 0; canvas.scrollLeft = 0; }
      },

      fitToView: function() {
        var canvas = document.getElementById('diagram-canvas');
        var content = document.getElementById('diagram-content');
        if (!canvas || !content) return;

        // Temporarily reset scale to measure actual content size
        this.scale = 1.0;
        this.apply();

        // Wait for layout to update
        setTimeout(function() {
          var canvasRect = canvas.getBoundingClientRect();
          var contentRect = content.getBoundingClientRect();

          // Calculate scale to fit content with padding
          var padding = 80;
          var scaleX = (canvasRect.width - padding) / contentRect.width;
          var scaleY = (canvasRect.height - padding) / contentRect.height;
          zoom.scale = Math.min(Math.max(Math.min(scaleX, scaleY), zoom.minScale), zoom.maxScale);
          zoom.scale = Math.round(zoom.scale * 100) / 100;
          zoom.apply();
          zoom.save();

          // Center content
          canvas.scrollTop = 0;
          canvas.scrollLeft = 0;
        }, 10);
      },

      zoomToPoint: function(delta, clientX, clientY) {
        var canvas = document.getElementById('diagram-canvas');
        if (!canvas) return;

        var oldScale = this.scale;
        var zoomDelta = delta > 0 ? -this.step : this.step;
        this.scale = Math.max(this.minScale, Math.min(this.maxScale, Math.round((this.scale + zoomDelta) * 100) / 100));

        if (this.scale !== oldScale) {
          // Get mouse position relative to canvas
          var rect = canvas.getBoundingClientRect();
          var mouseX = clientX - rect.left + canvas.scrollLeft;
          var mouseY = clientY - rect.top + canvas.scrollTop;

          // Calculate new scroll position to keep mouse point fixed
          var newScrollX = (mouseX * this.scale / oldScale) - (clientX - rect.left);
          var newScrollY = (mouseY * this.scale / oldScale) - (clientY - rect.top);

          this.apply();
          canvas.scrollLeft = Math.max(0, newScrollX);
          canvas.scrollTop = Math.max(0, newScrollY);
          this.save();
        }
      },

      save: function() {
        try {
          localStorage.setItem(STORAGE_KEY + '-zoom', JSON.stringify({ scale: this.scale }));
        } catch (e) { console.warn('Failed to save zoom:', e); }
      },

      load: function() {
        try {
          var saved = localStorage.getItem(STORAGE_KEY + '-zoom');
          if (saved) {
            var data = JSON.parse(saved);
            if (data.scale >= this.minScale && data.scale <= this.maxScale) {
              this.scale = data.scale;
              this.apply();
            }
          }
        } catch (e) { console.warn('Failed to load zoom:', e); }
      }
    };
    // ============ END ZOOM MANAGEMENT ============

    // ============ LIGHTWEIGHT MARKDOWN PARSER ============
    function parseMarkdown(text) {
      if (!text) return '';

      // Escape HTML to prevent XSS
      var escaped = text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');

      // Process code blocks first (```...```)
      escaped = escaped.replace(/```(\w*)\n([\s\S]*?)```/g, function(match, lang, code) {
        return '<pre><code>' + code.trim() + '</code></pre>';
      });

      // Process inline code (`...`)
      escaped = escaped.replace(/`([^`]+)`/g, '<code>$1</code>');

      // Process headers (## and ###)
      escaped = escaped.replace(/^#### (.+)$/gm, '<h4>$1</h4>');
      escaped = escaped.replace(/^### (.+)$/gm, '<h3>$1</h3>');
      escaped = escaped.replace(/^## (.+)$/gm, '<h2>$1</h2>');

      // Process bold (**text**)
      escaped = escaped.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');

      // Process italic (*text*)
      escaped = escaped.replace(/\*([^*]+)\*/g, '<em>$1</em>');

      // Process unordered lists
      escaped = escaped.replace(/^- (.+)$/gm, '<li>$1</li>');
      escaped = escaped.replace(/(<li>.*<\/li>\n?)+/g, '<ul>$&</ul>');

      // Process numbered lists
      escaped = escaped.replace(/^\d+\. (.+)$/gm, '<li>$1</li>');

      // Wrap remaining lines in paragraphs (skip if already wrapped in tags)
      var lines = escaped.split('\n');
      var result = [];
      var inList = false;

      for (var i = 0; i < lines.length; i++) {
        var line = lines[i].trim();
        if (!line) {
          result.push('');
          continue;
        }
        // Skip lines already wrapped in block tags
        if (line.match(/^<(h[234]|pre|ul|ol|li|p)/) || line.match(/<\/(h[234]|pre|ul|ol)>$/)) {
          result.push(line);
        } else if (line.match(/<\/li>$/)) {
          result.push(line);
        } else {
          result.push('<p>' + line + '</p>');
        }
      }

      // Clean up empty paragraphs and fix list wrapping
      var html = result.join('\n')
        .replace(/<p><\/p>/g, '')
        .replace(/<\/ul>\s*<ul>/g, '')
        .replace(/<p>(<ul>)/g, '$1')
        .replace(/(<\/ul>)<\/p>/g, '$1');

      return html;
    }
    // ============ END MARKDOWN PARSER ============

    function saveState() {
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify({
          annotations: state.annotations,
          componentData: state.componentData,
          treeStructure: state.treeStructure,
          workflowStructure: state.workflowStructure,
          dataFlowLayers: state.dataFlowLayers,
          sequenceFlows: state.sequenceFlows,
          version: 3
        }));
      } catch (e) { console.warn('Failed to save:', e); }
    }

    function loadState() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          const p = JSON.parse(saved);
          if (p.version === 3) {
            state.annotations = p.annotations || {};
            state.componentData = p.componentData || { ...INITIAL_COMPONENT_DATA };
            state.treeStructure = p.treeStructure || JSON.parse(JSON.stringify(INITIAL_TREE_STRUCTURE));
            state.workflowStructure = p.workflowStructure || (CONFIG.workflowStructureV2 ? JSON.parse(JSON.stringify(CONFIG.workflowStructureV2)) : null);
            state.dataFlowLayers = p.dataFlowLayers || (DATA_FLOW_LAYERS ? JSON.parse(JSON.stringify(DATA_FLOW_LAYERS)) : []);
            state.sequenceFlows = p.sequenceFlows || (SEQUENCE_FLOWS ? JSON.parse(JSON.stringify(SEQUENCE_FLOWS)) : []);
            return true;
          } else if (p.version === 2) {
            // Migrate from v2
            state.annotations = p.annotations || {};
            state.componentData = p.componentData || { ...INITIAL_COMPONENT_DATA };
            state.treeStructure = p.treeStructure || JSON.parse(JSON.stringify(INITIAL_TREE_STRUCTURE));
            state.workflowStructure = p.workflowStructure || (CONFIG.workflowStructureV2 ? JSON.parse(JSON.stringify(CONFIG.workflowStructureV2)) : null);
            return true;
          } else if (p.version === 1) {
            // Migrate from v1: only had annotations
            state.annotations = p.annotations || {};
            return true;
          }
        }
      } catch (e) { console.warn('Failed to load:', e); }
      return false;
    }

    function clearState() {
      if (confirm('Reset explorer to default state? This will clear all your annotations.')) {
        localStorage.removeItem(STORAGE_KEY);
        localStorage.removeItem(STORAGE_KEY + '-zoom');
        location.reload();
      }
    }

    function updateAnnotationsSummary() {
      var summary = document.getElementById('annotations-summary');
      var stats = document.getElementById('annotations-stats');
      var counts = { question: 0, comment: 0, edit: 0 };
      Object.values(state.annotations).forEach(function(list) {
        list.forEach(function(a) { counts[a.type]++; });
      });
      var total = counts.question + counts.comment + counts.edit;
      if (total > 0) {
        summary.classList.add('visible');
        stats.textContent = '';
        ['question', 'comment', 'edit'].forEach(function(type) {
          if (counts[type] > 0) {
            var item = document.createElement('div');
            item.className = 'stat-item';
            var dot = document.createElement('span');
            dot.className = 'stat-dot ' + type;
            item.appendChild(dot);
            item.appendChild(document.createTextNode(counts[type] + ' ' + type + 's'));
            stats.appendChild(item);
          }
        });
      } else { summary.classList.remove('visible'); }
    }

    function renderTree() {
      var tree = document.getElementById('component-tree');
      tree.textContent = '';
      state.treeStructure.forEach(function(section) {
        var sectionDiv = document.createElement('div');
        sectionDiv.className = 'tree-section';
        var header = document.createElement('div');
        header.className = 'tree-section-header';
        header.textContent = section.header;
        sectionDiv.appendChild(header);
        section.items.forEach(function(item) {
          var itemDiv = document.createElement('div');
          itemDiv.className = 'tree-item';
          if (state.selectedComponent === item.id) itemDiv.classList.add('active');
          if (state.annotations[item.id] && state.annotations[item.id].length > 0) itemDiv.classList.add('has-annotation');
          if (state.pendingAIRequests[item.id]) itemDiv.classList.add('loading');
          itemDiv.dataset.component = item.id;
          var icon = document.createElement('span');
          icon.className = 'icon ' + item.iconClass;
          icon.textContent = item.icon;
          itemDiv.appendChild(icon);
          var data = state.componentData[item.id];
          itemDiv.appendChild(document.createTextNode(data ? data.title.split(' (')[0] : item.id));
          itemDiv.addEventListener('click', function() { selectComponent(item.id); });
          itemDiv.addEventListener('contextmenu', function(e) { showContextMenu(e, item.id); });
          sectionDiv.appendChild(itemDiv);
        });
        tree.appendChild(sectionDiv);
      });
    }

    function renderWorkflowView() {
      var canvas = document.getElementById('diagram-content');
      canvas.textContent = '';
      if (!WORKFLOW_STRUCTURE || WORKFLOW_STRUCTURE.length === 0) {
        var placeholder = document.createElement('div');
        placeholder.style.cssText = 'color: #8b949e; padding: 40px; text-align: center;';
        placeholder.textContent = 'No workflow structure defined';
        canvas.appendChild(placeholder);
        return;
      }
      var diagram = document.createElement('div');
      diagram.className = 'workflow-diagram';
      WORKFLOW_STRUCTURE.forEach(function(row) {
        var rowDiv = document.createElement('div');
        rowDiv.className = 'phase-row';
        row.nodes.forEach(function(nodeId, idx) {
          if (idx > 0) {
            var arrow = document.createElement('span');
            arrow.className = 'arrow';
            arrow.textContent = '\u2192';
            rowDiv.appendChild(arrow);
          }
          rowDiv.appendChild(createNodeBox(nodeId, row.phase || ''));
        });
        diagram.appendChild(rowDiv);
      });
      canvas.appendChild(diagram);
    }

    function renderDataFlowView() {
      var canvas = document.getElementById('diagram-content');
      canvas.textContent = '';
      var diagram = document.createElement('div');
      diagram.className = 'data-flow-diagram';
      state.dataFlowLayers.forEach(function(layer) {
        var layerDiv = document.createElement('div');
        layerDiv.className = 'flow-layer';
        var label = document.createElement('div');
        label.className = 'flow-layer-label';
        label.textContent = layer.label;
        layerDiv.appendChild(label);
        var boxes = document.createElement('div');
        boxes.className = 'flow-boxes';
        layer.items.forEach(function(id) {
          var data = state.componentData[id] || { title: id };
          var box = document.createElement('div');
          box.className = 'flow-box';
          if (state.selectedComponent === id) box.classList.add('selected');
          if (state.annotations[id] && state.annotations[id].length > 0) box.classList.add('has-annotation');
          box.dataset.component = id;
          box.textContent = data.title.split(' (')[0];
          box.addEventListener('click', function() { selectComponent(id); });
          box.addEventListener('contextmenu', function(e) { showContextMenu(e, id); });
          // Add loading state if AI request pending
          renderNodeLoadingState(box, id);
          boxes.appendChild(box);
        });
        layerDiv.appendChild(boxes);
        diagram.appendChild(layerDiv);
      });
      canvas.appendChild(diagram);
    }

    function renderFilesView() {
      var canvas = document.getElementById('diagram-content');
      canvas.textContent = '';
      var tree = document.createElement('div');
      tree.className = 'file-tree';
      FILE_TREE_ENTRIES.forEach(function(f) {
        var entry = document.createElement('div');
        entry.className = 'file-entry';
        if (f.component && state.selectedComponent === f.component) entry.classList.add('selected');
        if (f.component && state.annotations[f.component] && state.annotations[f.component].length > 0) entry.classList.add('has-annotation');
        if (f.component) entry.dataset.component = f.component;
        if (f.indent) {
          var indent = document.createElement('span');
          indent.className = 'file-indent';
          indent.textContent = f.indent;
          entry.appendChild(indent);
        }
        var icon = document.createElement('span');
        icon.className = 'file-icon';
        icon.textContent = f.icon === 'D' ? 'D' : 'F';
        entry.appendChild(icon);
        entry.appendChild(document.createTextNode(' ' + f.text));
        if (f.component) {
          entry.addEventListener('click', function() { selectComponent(f.component); });
          entry.addEventListener('contextmenu', function(e) { showContextMenu(e, f.component); });
        }
        tree.appendChild(entry);
      });
      canvas.appendChild(tree);
    }

    function renderSequenceView() {
      var canvas = document.getElementById('diagram-content');
      canvas.textContent = '';
      if (!state.sequenceFlows || state.sequenceFlows.length === 0) {
        var placeholder = document.createElement('div');
        placeholder.style.cssText = 'color: #8b949e; padding: 40px; text-align: center;';
        placeholder.textContent = 'No sequence flows defined';
        canvas.appendChild(placeholder);
        return;
      }
      var diagram = document.createElement('div');
      diagram.className = 'sequence-diagram';
      state.sequenceFlows.forEach(function(flow) {
        var flowContainer = createSequenceFlow(flow);
        diagram.appendChild(flowContainer);
      });
      canvas.appendChild(diagram);
    }

    function createSequenceFlow(flow) {
      var container = document.createElement('div');
      container.className = 'sequence-flow';
      if (!flow.participants || !Array.isArray(flow.participants) || flow.participants.length === 0) {
        var error = document.createElement('div');
        error.style.cssText = 'color: #f85149; padding: 12px;';
        error.textContent = 'Invalid sequence flow: missing participants';
        container.appendChild(error);
        return container;
      }
      if (flow.name) {
        var title = document.createElement('div');
        title.className = 'sequence-flow-title';
        title.textContent = flow.name;
        container.appendChild(title);
      }
      var header = document.createElement('div');
      header.className = 'participant-header';
      header.style.gridTemplateColumns = 'repeat(' + flow.participants.length + ', 1fr)';
      flow.participants.forEach(function(p) {
        var box = document.createElement('div');
        box.className = 'participant-box';
        var data = state.componentData[p.id];
        box.textContent = data ? data.title.split(' (')[0] : (p.name || p.id || 'Unknown');
        box.dataset.participantId = p.id;
        header.appendChild(box);
      });
      container.appendChild(header);
      var timeline = document.createElement('div');
      timeline.className = 'sequence-timeline';
      timeline.style.gridTemplateColumns = 'repeat(' + flow.participants.length + ', 1fr)';
      var messages = flow.messages || [];
      var timelineHeight = Math.max(100, messages.length * 60 + 40);
      timeline.style.minHeight = timelineHeight + 'px';
      flow.participants.forEach(function(p) {
        var column = document.createElement('div');
        column.className = 'lifeline-column';
        var lifeline = document.createElement('div');
        lifeline.className = 'lifeline';
        column.appendChild(lifeline);
        timeline.appendChild(column);
      });
      var messagesLayer = document.createElement('div');
      messagesLayer.className = 'messages-layer';
      messages.forEach(function(msg) {
        if (!msg.from || !msg.to) return;
        var fromIdx = flow.participants.findIndex(function(p) { return p.id === msg.from; });
        var toIdx = flow.participants.findIndex(function(p) { return p.id === msg.to; });
        if (fromIdx === -1 || toIdx === -1) return;
        var messageRow = document.createElement('div');
        messageRow.className = 'message-row';
        messageRow.style.gridTemplateColumns = 'repeat(' + flow.participants.length + ', 1fr)';
        var arrow = createMessageArrow(msg, fromIdx, toIdx, flow.participants.length);
        messageRow.appendChild(arrow);
        messagesLayer.appendChild(messageRow);
      });
      timeline.appendChild(messagesLayer);
      container.appendChild(timeline);
      return container;
    }

    function createMessageArrow(message, fromIndex, toIndex, participantCount) {
      var arrow = document.createElement('div');
      arrow.className = 'message-arrow';
      if (message.id) arrow.dataset.component = message.id;
      if (message.type === 'return') arrow.classList.add('return');
      if (message.type === 'async') arrow.classList.add('async');
      var isSelfCall = fromIndex === toIndex;
      if (isSelfCall) {
        arrow.classList.add('self-call');
        arrow.style.gridColumn = (fromIndex + 1) + ' / ' + (fromIndex + 2);
      } else {
        var colStart = Math.min(fromIndex, toIndex) + 1;
        var colEnd = Math.max(fromIndex, toIndex) + 2;
        arrow.style.gridColumn = colStart + ' / ' + colEnd;
        if (fromIndex > toIndex) arrow.classList.add('reverse');
      }
      var label = document.createElement('span');
      label.className = 'message-label';
      label.textContent = message.label || '';
      arrow.appendChild(label);
      if (message.id) {
        if (state.selectedComponent === message.id) arrow.classList.add('selected');
        if (state.annotations[message.id] && state.annotations[message.id].length > 0) {
          arrow.classList.add('has-annotation');
        }
        arrow.addEventListener('click', function() { selectComponent(message.id); });
        arrow.addEventListener('contextmenu', function(e) { showContextMenu(e, message.id); });
        // Add loading state if AI request pending
        renderNodeLoadingState(arrow, message.id);
      }
      return arrow;
    }

    // ========== Enhanced Workflow (V2) ==========

    function computeWorkflowLayout(workflow) {
      if (!workflow || !workflow.nodes || !workflow.edges) {
        return { layers: [], nodePositions: new Map(), edgeRoutes: [], nodeMap: new Map() };
      }

      var adjList = new Map();
      var inDegree = new Map();
      var nodeMap = new Map();

      workflow.nodes.forEach(function(node) {
        nodeMap.set(node.id, node);
        adjList.set(node.id, []);
        inDegree.set(node.id, 0);
      });

      workflow.edges.forEach(function(edge) {
        if (!adjList.has(edge.from) || !adjList.has(edge.to)) return;
        // Skip loop edges for layer calculation
        if (edge.type === 'loop') return;
        adjList.get(edge.from).push(edge);
        inDegree.set(edge.to, inDegree.get(edge.to) + 1);
      });

      // Topological sort with longest path layer assignment
      var nodeLayer = new Map();
      var queue = [];

      // Find start nodes
      workflow.nodes.forEach(function(node) {
        if (inDegree.get(node.id) === 0 || node.type === 'start') {
          queue.push({ id: node.id, layer: 0 });
          nodeLayer.set(node.id, 0);
        }
      });

      // Handle disconnected nodes (fallback)
      if (queue.length === 0 && workflow.nodes.length > 0) {
        queue.push({ id: workflow.nodes[0].id, layer: 0 });
        nodeLayer.set(workflow.nodes[0].id, 0);
      }

      // Prevent infinite loops with malformed configs
      var maxIterations = workflow.nodes.length * workflow.edges.length + workflow.nodes.length;
      var iterations = 0;

      while (queue.length > 0) {
        if (++iterations > maxIterations) {
          console.error('Workflow layout: exceeded max iterations, possible circular dependency');
          break;
        }
        var current = queue.shift();
        var edges = adjList.get(current.id) || [];
        edges.forEach(function(edge) {
          var childId = edge.to;
          var childLayer = current.layer + 1;
          if (!nodeLayer.has(childId) || nodeLayer.get(childId) < childLayer) {
            nodeLayer.set(childId, childLayer);
            queue.push({ id: childId, layer: childLayer });
          }
        });
      }

      // Handle any remaining unvisited nodes
      workflow.nodes.forEach(function(node) {
        if (!nodeLayer.has(node.id)) {
          nodeLayer.set(node.id, 0);
        }
      });

      // Build layers array
      var maxLayer = 0;
      nodeLayer.forEach(function(layer) { maxLayer = Math.max(maxLayer, layer); });

      var layers = [];
      for (var i = 0; i <= maxLayer; i++) layers.push([]);

      nodeLayer.forEach(function(layer, nodeId) {
        layers[layer].push(nodeId);
      });

      // Compute node positions
      var nodePositions = new Map();
      layers.forEach(function(layer, layerIndex) {
        layer.forEach(function(nodeId, posIndex) {
          nodePositions.set(nodeId, {
            layer: layerIndex,
            position: posIndex,
            total: layer.length
          });
        });
      });

      // Compute edge routes (including loops)
      var edgeRoutes = workflow.edges.map(function(edge) {
        var fromPos = nodePositions.get(edge.from);
        var toPos = nodePositions.get(edge.to);
        if (!fromPos || !toPos) {
          console.warn('Workflow edge skipped: node not found', {
            edge: edge,
            fromExists: !!fromPos,
            toExists: !!toPos
          });
          return null;
        }

        return {
          id: edge.id,
          from: edge.from,
          to: edge.to,
          fromPos: fromPos,
          toPos: toPos,
          label: edge.label,
          type: edge.type === 'loop' || toPos.layer <= fromPos.layer ? 'loop' : 'straight',
          branch: edge.branch || null
        };
      }).filter(Boolean);

      return { layers: layers, nodePositions: nodePositions, edgeRoutes: edgeRoutes, nodeMap: nodeMap };
    }

    function createArrowMarker(id, color) {
      var marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
      marker.setAttribute('id', id);
      marker.setAttribute('markerWidth', '10');
      marker.setAttribute('markerHeight', '10');
      marker.setAttribute('refX', '9');
      marker.setAttribute('refY', '3');
      marker.setAttribute('orient', 'auto');
      var polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      polygon.setAttribute('points', '0 0, 10 3, 0 6');
      polygon.setAttribute('fill', color);
      marker.appendChild(polygon);
      return marker;
    }

    function renderEnhancedWorkflow() {
      var canvas = document.getElementById('diagram-content');
      canvas.textContent = '';

      var workflow = state.workflowStructure;
      console.log('renderEnhancedWorkflow - workflow:', workflow);
      console.log('renderEnhancedWorkflow - nodes count:', workflow ? workflow.nodes.length : 0);
      if (!workflow || !workflow.nodes || workflow.nodes.length === 0) {
        renderWorkflowView();
        return;
      }

      var layout = computeWorkflowLayout(workflow);
      if (layout.layers.length === 0) {
        var placeholder = document.createElement('div');
        placeholder.style.cssText = 'color: #8b949e; padding: 40px; text-align: center;';
        placeholder.textContent = 'No workflow nodes found';
        canvas.appendChild(placeholder);
        return;
      }

      var diagram = document.createElement('div');
      diagram.className = 'workflow-diagram-v2';

      var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('class', 'workflow-edges');
      var defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      defs.appendChild(createArrowMarker('workflow-arrow', '#58a6ff'));
      defs.appendChild(createArrowMarker('workflow-arrow-loop', '#a371f7'));
      defs.appendChild(createArrowMarker('workflow-arrow-secondary', '#8b949e'));
      svg.appendChild(defs);
      diagram.appendChild(svg);

      var nodeElements = new Map();

      layout.layers.forEach(function(layerNodes, layerIndex) {
        var layerDiv = document.createElement('div');
        layerDiv.className = 'workflow-layer';
        layerDiv.dataset.layer = layerIndex;

        layerNodes.forEach(function(nodeId) {
          var node = layout.nodeMap.get(nodeId);
          var nodeEl = createWorkflowNode(node);
          nodeElements.set(nodeId, nodeEl);
          layerDiv.appendChild(nodeEl);
        });

        diagram.appendChild(layerDiv);
      });

      canvas.appendChild(diagram);

      // Render edges after DOM layout
      setTimeout(function() {
        var diagramRect = diagram.getBoundingClientRect();
        // Account for zoom scale when setting SVG dimensions
        var scaledWidth = diagramRect.width / zoom.scale;
        var scaledHeight = diagramRect.height / zoom.scale;
        svg.setAttribute('width', scaledWidth);
        svg.setAttribute('height', scaledHeight);

        var svgRect = diagram.getBoundingClientRect();
        layout.edgeRoutes.forEach(function(route) {
          var fromEl = nodeElements.get(route.from);
          var toEl = nodeElements.get(route.to);
          if (fromEl && toEl) {
            var edge = createWorkflowEdge(route, fromEl, toEl, svgRect, zoom.scale);
            if (edge) svg.appendChild(edge);
          }
        });
      }, 50);
    }

    function createWorkflowNode(node) {
      var wrapper = document.createElement('div');
      var nodeType = node.type || 'process';
      wrapper.className = 'workflow-node workflow-node-' + nodeType;
      if (node.phase) wrapper.classList.add(node.phase);

      var componentId = node.componentId || node.id;
      wrapper.dataset.component = componentId;

      if (state.selectedComponent === componentId) {
        wrapper.classList.add('selected');
      }
      if (state.annotations[componentId] && state.annotations[componentId].length > 0) {
        wrapper.classList.add('has-annotation');
        wrapper.dataset.annotationCount = state.annotations[componentId].length;
      }

      wrapper.addEventListener('click', function() { selectComponent(componentId); });
      wrapper.addEventListener('contextmenu', function(e) { showContextMenu(e, componentId); });

      if (nodeType === 'decision') {
        var content = document.createElement('div');
        content.className = 'decision-content';
        content.textContent = node.label || '?';
        wrapper.appendChild(content);
      } else if (nodeType === 'merge') {
        wrapper.textContent = '\u2295';
      } else if (nodeType === 'start' || nodeType === 'end') {
        wrapper.textContent = node.label || (nodeType === 'start' ? 'Start' : 'End');
      } else {
        var title = document.createElement('div');
        title.className = 'workflow-node-title';
        title.textContent = node.label || 'Process';
        wrapper.appendChild(title);

        if (state.componentData[componentId]) {
          var subtitle = document.createElement('div');
          subtitle.className = 'workflow-node-subtitle';
          subtitle.textContent = state.componentData[componentId].badgeLabel || '';
          wrapper.appendChild(subtitle);
        }
      }

      // Add loading state if AI request pending
      renderNodeLoadingState(wrapper, componentId);

      return wrapper;
    }

    function createWorkflowEdge(route, fromEl, toEl, svgRect, zoomScale) {
      var fromRect = fromEl.getBoundingClientRect();
      var toRect = toEl.getBoundingClientRect();
      var scale = zoomScale || 1;

      // Check if source is a decision node (diamond shape)
      var isFromDecision = fromEl.classList.contains('workflow-node-decision');

      // Divide by zoom scale to get unscaled coordinates for SVG
      var fromCenterX = (fromRect.left + fromRect.width / 2 - svgRect.left) / scale;
      var fromCenterY = (fromRect.top + fromRect.height / 2 - svgRect.top) / scale;
      var toX = (toRect.left + toRect.width / 2 - svgRect.left) / scale;
      var toY = (toRect.top - svgRect.top) / scale;

      var fromX, fromY;

      if (isFromDecision) {
        // For decision nodes (diamond), calculate exit points based on direction
        // Diamond has corners at top, bottom, left, right of the center
        var halfWidth = (fromRect.width / 2) / scale;
        var halfHeight = (fromRect.height / 2) / scale;

        if (route.branch === 'secondary') {
          // Secondary branch exits from the right corner of the diamond
          fromX = fromCenterX + halfWidth * 0.7;  // Right corner (adjusted for rotation)
          fromY = fromCenterY;
        } else {
          // Primary branch exits from the bottom corner of the diamond
          fromX = fromCenterX;
          fromY = fromCenterY + halfHeight * 0.7;  // Bottom corner (adjusted for rotation)
        }
      } else {
        // Regular nodes: exit from bottom center
        fromX = fromCenterX;
        fromY = (fromRect.bottom - svgRect.top) / scale;
      }

      var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('class', 'workflow-edge');

      var d;
      if (route.type === 'loop') {
        // Curved loop-back path on the right side
        var controlOffset = 100;
        var controlX = Math.max(fromX, toX) + controlOffset;
        d = 'M ' + fromX + ' ' + fromY + ' C ' + controlX + ' ' + fromY + ', ' + controlX + ' ' + toY + ', ' + toX + ' ' + toY;
        path.classList.add('loop');
        path.setAttribute('marker-end', 'url(#workflow-arrow-loop)');
      } else {
        if (isFromDecision && route.branch === 'secondary') {
          // Secondary branch from decision: curve from right side to target
          var midX = fromX + 40;  // Control point offset
          var midY = (fromY + toY) / 2;
          d = 'M ' + fromX + ' ' + fromY + ' Q ' + midX + ' ' + fromY + ', ' + midX + ' ' + midY + ' Q ' + midX + ' ' + toY + ', ' + toX + ' ' + toY;
        } else if (Math.abs(fromX - toX) < 10) {
          // Straight vertical path
          d = 'M ' + fromX + ' ' + fromY + ' L ' + toX + ' ' + toY;
        } else {
          // Angled path with midpoint
          var midY = (fromY + toY) / 2;
          d = 'M ' + fromX + ' ' + fromY + ' L ' + fromX + ' ' + midY + ' L ' + toX + ' ' + midY + ' L ' + toX + ' ' + toY;
        }

        if (route.branch === 'secondary') {
          path.classList.add('secondary');
          path.setAttribute('marker-end', 'url(#workflow-arrow-secondary)');
        } else {
          path.setAttribute('marker-end', 'url(#workflow-arrow)');
        }
      }

      path.setAttribute('d', d);

      if (route.id) {
        path.dataset.edgeId = route.id;
      }

      return path;
    }

    // ========== End Enhanced Workflow ==========

    function renderCurrentView() {
      if (state.currentView === 'workflow') {
        if (state.workflowStructure) {
          renderEnhancedWorkflow();
        } else {
          renderWorkflowView();
        }
      }
      else if (state.currentView === 'dataflow') renderDataFlowView();
      else if (state.currentView === 'files') renderFilesView();
      else if (state.currentView === 'sequence') renderSequenceView();
    }

    function createNodeBox(id, phaseClass) {
      var data = state.componentData[id] || { title: id, badgeLabel: '' };
      var box = document.createElement('div');
      box.className = 'node-box ' + phaseClass;
      if (state.selectedComponent === id) box.classList.add('selected');
      if (state.annotations[id] && state.annotations[id].length > 0) {
        box.classList.add('has-annotation');
        var badge = document.createElement('div');
        badge.className = 'annotation-badge';
        badge.textContent = state.annotations[id].length;
        box.appendChild(badge);
      }
      box.dataset.component = id;
      var title = document.createElement('div');
      title.className = 'node-title';
      title.textContent = data.title.split(' (')[0];
      box.appendChild(title);
      var subtitle = document.createElement('div');
      subtitle.className = 'node-subtitle';
      subtitle.textContent = data.badgeLabel || '';
      box.appendChild(subtitle);
      box.addEventListener('click', function() { selectComponent(id); });
      box.addEventListener('contextmenu', function(e) { showContextMenu(e, id); });
      // Add loading state if AI request pending
      renderNodeLoadingState(box, id);
      return box;
    }

    function selectComponent(id) {
      state.selectedComponent = id;
      updateDetails();
      renderCurrentView();
      renderTree();
    }

    function renderEmptyState() {
      var detailContent = document.getElementById('detail-content');
      detailContent.textContent = '';
      var section = document.createElement('div');
      section.className = 'detail-section';
      var title = document.createElement('div');
      title.className = 'detail-section-title';
      title.textContent = 'Getting Started';
      section.appendChild(title);
      var text = document.createElement('p');
      text.className = 'detail-text';
      text.textContent = 'Click on any component in the tree or diagram to see details. Right-click to add annotations.';
      section.appendChild(text);
      detailContent.appendChild(section);
    }

    function updateDetails() {
      var id = state.selectedComponent;
      var data = state.componentData[id];
      var detailContent = document.getElementById('detail-content');
      var detailTitle = document.getElementById('detail-title');
      var detailBadge = document.getElementById('detail-badge');

      // Check if we have annotations for this component even without componentData
      var annotations = state.annotations[id] || [];

      if (!data && annotations.length === 0) {
        detailTitle.textContent = 'Select a component';
        detailBadge.style.display = 'none';
        renderEmptyState();
        return;
      }

      // Show title from componentData or use the ID
      detailTitle.textContent = data ? data.title : id;
      if (data) {
        detailBadge.textContent = data.badgeLabel;
        detailBadge.className = 'details-badge badge-' + data.badge;
        detailBadge.style.display = 'inline';
      } else {
        detailBadge.style.display = 'none';
      }
      detailContent.textContent = '';

      if (annotations.length > 0) {
        var annoSection = document.createElement('div');
        annoSection.className = 'annotations-section';
        var annoTitle = document.createElement('div');
        annoTitle.className = 'detail-section-title';
        annoTitle.textContent = 'Annotations (' + annotations.length + ')';
        annoSection.appendChild(annoTitle);
        annotations.forEach(function(a, idx) {
          var item = document.createElement('div');
          item.className = 'annotation-item' + (a.type === 'ai' ? ' ai-annotation' : '');
          var header = document.createElement('div');
          header.className = 'annotation-header';
          var type = document.createElement('span');
          type.className = 'annotation-type ' + a.type;
          if (a.type === 'ai') {
            type.textContent = 'AI: ' + (a.action || 'response');
          } else {
            type.textContent = a.type;
          }
          header.appendChild(type);
          if (a.type === 'ai' && a.timestamp) {
            var timeAgo = document.createElement('span');
            timeAgo.className = 'annotation-ai-badge';
            var elapsed = Date.now() - a.timestamp;
            var mins = Math.floor(elapsed / 60000);
            timeAgo.textContent = mins < 1 ? 'just now' : mins + 'm ago';
            header.appendChild(timeAgo);
          }
          var deleteBtn = document.createElement('button');
          deleteBtn.className = 'annotation-delete';
          deleteBtn.textContent = 'x';
          deleteBtn.addEventListener('click', function() {
            state.annotations[id].splice(idx, 1);
            if (state.annotations[id].length === 0) delete state.annotations[id];
            saveState(); updateAnnotationsSummary(); renderCurrentView(); renderTree(); updateDetails();
          });
          header.appendChild(deleteBtn);
          item.appendChild(header);
          // Add expand/collapse button at top for long AI responses
          var expandBtn = null;
          if (a.type === 'ai' && a.text && a.text.length > 200) {
            expandBtn = document.createElement('button');
            expandBtn.className = 'annotation-expand-btn';
            expandBtn.textContent = a.collapsed ? 'Show more' : 'Show less';
            expandBtn.addEventListener('click', function() {
              a.collapsed = !a.collapsed;
              saveState();
              updateDetails();
            });
            item.appendChild(expandBtn);
          }
          var textContainer = document.createElement('div');
          textContainer.className = 'annotation-text' + (a.collapsed ? ' annotation-collapsed' : '');
          // Use markdown rendering for AI responses, plain text for user annotations
          if (a.type === 'ai') {
            textContainer.classList.add('markdown');
            // parseMarkdown escapes HTML before processing, safe to use innerHTML
            textContainer.innerHTML = parseMarkdown(a.text);
          } else {
            textContainer.textContent = a.text;
          }
          item.appendChild(textContainer);
          if (a.prompt) {
            var promptDiv = document.createElement('div');
            promptDiv.className = 'annotation-prompt';
            promptDiv.textContent = a.prompt;
            // Only show prompt for AI annotations, not for user comments/edits
            if (a.type === 'ai') {
              item.appendChild(promptDiv);
            }
          }
          annoSection.appendChild(item);
        });
        var addBtn = document.createElement('button');
        addBtn.className = 'add-annotation-btn';
        addBtn.textContent = '+ Add another annotation';
        addBtn.addEventListener('click', function() { openAnnotationModal(id); });
        annoSection.appendChild(addBtn);
        detailContent.appendChild(annoSection);
      }

      // Only show component details if we have componentData
      if (data) {
        if (data.file) {
          var fileDiv = document.createElement('div');
          fileDiv.className = 'detail-file';
          fileDiv.textContent = data.file;
          detailContent.appendChild(fileDiv);
        }

        var descSection = document.createElement('div');
        descSection.className = 'detail-section';
        var descTitle = document.createElement('div');
        descTitle.className = 'detail-section-title';
        descTitle.textContent = 'Description';
        descSection.appendChild(descTitle);
        var descText = document.createElement('p');
        descText.className = 'detail-text';
        descText.textContent = data.description;
        descSection.appendChild(descText);
        detailContent.appendChild(descSection);

        if (data.responsibilities) {
          var respSection = document.createElement('div');
          respSection.className = 'detail-section';
          var respTitle = document.createElement('div');
          respTitle.className = 'detail-section-title';
          respTitle.textContent = 'Responsibilities';
          respSection.appendChild(respTitle);
          var respList = document.createElement('ul');
          respList.className = 'detail-list';
          data.responsibilities.forEach(function(r) {
            var li = document.createElement('li');
            li.textContent = r;
            respList.appendChild(li);
          });
          respSection.appendChild(respList);
          detailContent.appendChild(respSection);
        }

        if (data.code) {
          var codeSection = document.createElement('div');
          codeSection.className = 'detail-section';
          var codeTitle = document.createElement('div');
          codeTitle.className = 'detail-section-title';
          codeTitle.textContent = 'Interface / Code';
          codeSection.appendChild(codeTitle);
          var codePre = document.createElement('pre');
          codePre.className = 'detail-code';
          codePre.textContent = data.code;
          codeSection.appendChild(codePre);
          detailContent.appendChild(codeSection);
        }
      }

      if (annotations.length === 0) {
        var actSection = document.createElement('div');
        actSection.className = 'detail-section';
        var actTitle = document.createElement('div');
        actTitle.className = 'detail-section-title';
        actTitle.textContent = 'Annotate';
        actSection.appendChild(actTitle);
        var addBtn = document.createElement('button');
        addBtn.className = 'add-annotation-btn';
        addBtn.textContent = '+ Add annotation (or right-click)';
        addBtn.addEventListener('click', function() { openAnnotationModal(id); });
        actSection.appendChild(addBtn);
        detailContent.appendChild(actSection);
      }
    }

    function showContextMenu(e, componentId) {
      e.preventDefault();
      state.contextTarget = componentId;
      var menu = document.getElementById('context-menu');
      menu.style.left = e.clientX + 'px';
      menu.style.top = e.clientY + 'px';
      menu.classList.add('visible');
    }

    function hideContextMenu() { document.getElementById('context-menu').classList.remove('visible'); }
    document.addEventListener('click', hideContextMenu);

    document.querySelectorAll('.context-menu-item').forEach(function(item) {
      item.addEventListener('click', function() {
        // Skip AI actions - they have their own handler
        if (item.classList.contains('ai-action')) return;
        var action = item.dataset.action;
        if (action === 'view') selectComponent(state.contextTarget);
        else openAnnotationModal(state.contextTarget, action);
        hideContextMenu();
      });
    });

    function openAnnotationModal(componentId, type) {
      state.contextTarget = componentId;
      var data = state.componentData[componentId] || { title: componentId };
      document.getElementById('modal-title').textContent = 'Annotate: ' + data.title;
      document.getElementById('annotation-type').value = type || 'question';
      document.getElementById('annotation-text').value = '';
      document.getElementById('modal-overlay').classList.add('visible');
      document.getElementById('annotation-text').focus();
    }

    document.getElementById('modal-cancel').addEventListener('click', function() {
      document.getElementById('modal-overlay').classList.remove('visible');
    });

    document.getElementById('modal-save').addEventListener('click', function() {
      var type = document.getElementById('annotation-type').value;
      var text = document.getElementById('annotation-text').value.trim();
      if (text) {
        // If it's a question and AI is available, send to AI (AI response includes the question)
        if (type === 'question' && bridgeAvailable) {
          triggerAIQuestion(state.contextTarget, text);
        } else {
          // For comments/edits, or questions without AI, save as regular annotation
          var prompt = generatePromptForAnnotation(state.contextTarget, type, text);
          if (!state.annotations[state.contextTarget]) state.annotations[state.contextTarget] = [];
          state.annotations[state.contextTarget].push({ type: type, text: text, prompt: prompt, timestamp: Date.now() });
          saveState(); updateAnnotationsSummary(); renderCurrentView(); renderTree(); selectComponent(state.contextTarget);
        }
      }
      document.getElementById('modal-overlay').classList.remove('visible');
    });

    function generatePromptForAnnotation(componentId, type, text) {
      var data = state.componentData[componentId] || { title: componentId, file: '' };
      var prompt = 'In the ' + PROJECT_NAME + ' codebase';
      if (type === 'question') {
        prompt = text + '\n\nContext: This question is about the ' + data.title + ' component';
        if (data.file) prompt += ' in ' + data.file;
        prompt += '.';
      } else if (type === 'comment') {
        prompt = 'I have an observation about ' + data.title + ': ' + text;
        prompt += '\n\nCan you provide more context or confirm this understanding?';
        if (data.file) prompt += '\n\nFile: ' + data.file;
      } else if (type === 'edit') {
        prompt = 'I want to make an edit to ' + data.title + ': ' + text;
        prompt += '\n\nCan you help me implement this change?';
        if (data.file) prompt += '\n\nFile: ' + data.file;
      }
      return prompt;
    }

    document.getElementById('modal-overlay').addEventListener('click', function(e) {
      if (e.target === this) this.classList.remove('visible');
    });

    document.getElementById('ask-btn').addEventListener('click', function() {
      var q = document.getElementById('question-input').value.trim();
      if (q) {
        var comp = state.selectedComponent;
        var prompt = q;
        if (comp && state.componentData[comp]) {
          var data = state.componentData[comp];
          prompt += '\n\nContext: Looking at ' + data.title;
          if (data.file) prompt += ' (' + data.file + ')';
          prompt += ' in the ' + PROJECT_NAME + ' codebase.';
        } else {
          prompt += '\n\nContext: ' + PROJECT_NAME + ' codebase.';
        }
        var targetId = comp || 'general';
        if (!state.annotations[targetId]) state.annotations[targetId] = [];
        state.annotations[targetId].push({ type: 'question', text: q, prompt: prompt, timestamp: Date.now() });
        saveState(); updateAnnotationsSummary();
        if (comp) selectComponent(comp);
        else updateDetails();
        document.getElementById('question-input').value = '';
      }
    });

    document.getElementById('question-input').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') document.getElementById('ask-btn').click();
    });

    document.querySelectorAll('.view-tab').forEach(function(tab) {
      tab.addEventListener('click', function() {
        state.currentView = tab.dataset.view;
        document.querySelectorAll('.view-tab').forEach(function(t) { t.classList.remove('active'); });
        tab.classList.add('active');
        renderCurrentView();
      });
    });

    document.getElementById('export-btn').addEventListener('click', function() {
      var output = 'Architecture Annotations - ' + PROJECT_NAME + '\n' + '='.repeat(50) + '\n\n';
      Object.keys(state.annotations).forEach(function(key) {
        var data = state.componentData[key] || { title: key };
        output += '## ' + data.title + '\n';
        state.annotations[key].forEach(function(a) { output += '- [' + a.type.toUpperCase() + '] ' + a.text + '\n'; });
        output += '\n';
      });
      navigator.clipboard.writeText(output).then(function() { alert('Annotations exported to clipboard!'); });
    });

    document.getElementById('reset-btn').addEventListener('click', clearState);
    document.getElementById('clear-btn').addEventListener('click', function() {
      if (confirm('Clear all annotations?')) {
        state.annotations = {};
        saveState(); updateAnnotationsSummary(); renderCurrentView(); renderTree(); updateDetails();
      }
    });

    // ============ ZOOM EVENT LISTENERS ============
    document.getElementById('zoom-in').addEventListener('click', function() { zoom.zoomIn(); });
    document.getElementById('zoom-out').addEventListener('click', function() { zoom.zoomOut(); });
    document.getElementById('zoom-reset').addEventListener('click', function() { zoom.reset(); });
    document.getElementById('zoom-fit').addEventListener('click', function() { zoom.fitToView(); });

    // Mouse wheel zoom (Ctrl/Cmd + wheel)
    document.getElementById('diagram-canvas').addEventListener('wheel', function(e) {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        zoom.zoomToPoint(e.deltaY, e.clientX, e.clientY);
      }
    }, { passive: false });

    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
      // Only handle if not focused on input elements
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT') return;

      if ((e.ctrlKey || e.metaKey) && e.key === '0') {
        e.preventDefault();
        zoom.reset();
      } else if ((e.ctrlKey || e.metaKey) && (e.key === '=' || e.key === '+')) {
        e.preventDefault();
        zoom.zoomIn();
      } else if ((e.ctrlKey || e.metaKey) && e.key === '-') {
        e.preventDefault();
        zoom.zoomOut();
      }
    });
    // ============ END ZOOM EVENT LISTENERS ============

    // ============ AI BRIDGE INTEGRATION ============
    var bridgeAvailable = false;

    function updateBridgeStatus(connected) {
      bridgeAvailable = connected;
      var statusEl = document.getElementById('bridge-status');
      var textEl = statusEl.querySelector('.status-text');
      statusEl.classList.remove('connected', 'disconnected', 'connecting');
      statusEl.classList.add(connected ? 'connected' : 'disconnected');
      textEl.textContent = connected ? 'AI Connected' : 'AI Disconnected';

      // Update AI action items visibility
      document.querySelectorAll('.context-menu-item.ai-action').forEach(function(item) {
        item.classList.toggle('disabled', !connected);
      });
    }

    function initBridgeClient() {
      if (!window.BridgeClient) {
        console.log('Bridge client not available - AI features disabled');
        updateBridgeStatus(false);
        return;
      }

      // Set up connection monitoring
      window.BridgeClient.onStatusChange(updateBridgeStatus);
      window.BridgeClient.startConnectionMonitor(10000);

      // Set up AI action handlers
      setupAIActionHandlers();
    }

    function setupAIActionHandlers() {
      document.querySelectorAll('.context-menu-item.ai-action').forEach(function(item) {
        item.addEventListener('click', function(e) {
          if (!bridgeAvailable) {
            alert('AI is not connected. Please ensure Claude Code is running with the playground-bridge MCP server.');
            return;
          }
          var action = item.dataset.aiAction;
          var componentId = state.contextTarget;
          if (componentId) {
            if (action === 'modify-graph') {
              openGraphModifyModal(componentId);
            } else {
              triggerAIAction(action, componentId);
            }
          }
          hideContextMenu();
        });
      });
    }

    function triggerAIAction(action, componentId) {
      if (state.pendingAIRequests[componentId]) {
        console.log('AI request already pending for', componentId);
        return;
      }

      var data = state.componentData[componentId] || { title: componentId };
      var context = {
        nodeTitle: data.title,
        nodeDescription: data.description || '',
        projectName: PROJECT_NAME,
        file: data.file || '',
        neighbors: getNeighborNodes(componentId)
      };

      state.pendingAIRequests[componentId] = true;
      renderCurrentView(); // Show loading spinner

      if (window.generateAIPrompt) {
        context.prompt = window.generateAIPrompt(action, 'architecture', context);
      }

      window.BridgeClient.sendAndWait(action, componentId, 'architecture', context, function(progress) {
        console.log('AI request progress:', progress.elapsed + 'ms');
      }).then(function(response) {
        delete state.pendingAIRequests[componentId];

        // Add AI response as annotation
        if (!state.annotations[componentId]) state.annotations[componentId] = [];
        state.annotations[componentId].unshift({
          type: 'ai',
          action: action,
          text: response.content,
          timestamp: Date.now(),
          collapsed: false
        });

        saveState();
        updateAnnotationsSummary();
        renderCurrentView();
        renderTree();
        if (state.selectedComponent === componentId) {
          updateDetails();
        }
      }).catch(function(err) {
        delete state.pendingAIRequests[componentId];
        console.error('AI action failed:', err);
        alert('AI request failed: ' + err.message);
        renderCurrentView();
      });
    }

    function triggerAIQuestion(componentId, questionText) {
      if (state.pendingAIRequests[componentId]) {
        console.log('AI request already pending for', componentId);
        return;
      }

      var data = state.componentData[componentId] || { title: componentId };
      var context = {
        nodeTitle: data.title,
        nodeDescription: data.description || '',
        projectName: PROJECT_NAME,
        file: data.file || '',
        neighbors: getNeighborNodes(componentId),
        prompt: questionText + '\n\nContext: ' + data.title + (data.file ? ' (' + data.file + ')' : '') + ' in ' + PROJECT_NAME
      };

      state.pendingAIRequests[componentId] = true;
      renderCurrentView(); // Show loading spinner

      window.BridgeClient.sendAndWait('question', componentId, 'architecture', context).then(function(response) {
        delete state.pendingAIRequests[componentId];

        // Add AI response as annotation
        if (!state.annotations[componentId]) state.annotations[componentId] = [];
        state.annotations[componentId].unshift({
          type: 'ai',
          action: 'question',
          question: questionText,
          text: response.content,
          timestamp: Date.now(),
          collapsed: false
        });

        saveState();
        updateAnnotationsSummary();
        renderCurrentView();
        renderTree();
        if (state.selectedComponent === componentId) {
          updateDetails();
        }
      }).catch(function(err) {
        delete state.pendingAIRequests[componentId];
        console.error('AI question failed:', err);
        alert('AI request failed: ' + err.message);
        renderCurrentView();
      });
    }

    function getNeighborNodes(componentId) {
      // Get connected nodes from workflow structure or data flow
      var neighbors = [];
      if (WORKFLOW_STRUCTURE && WORKFLOW_STRUCTURE.layers) {
        WORKFLOW_STRUCTURE.layers.forEach(function(layer) {
          layer.nodes.forEach(function(node) {
            if (node.id === componentId && node.connections) {
              neighbors = neighbors.concat(node.connections);
            }
          });
        });
      }
      return neighbors.slice(0, 5); // Limit to 5 neighbors
    }

    function renderNodeLoadingState(nodeElement, componentId) {
      if (state.pendingAIRequests[componentId]) {
        var existing = nodeElement.querySelector('.node-loading');
        if (!existing) {
          var loader = document.createElement('div');
          loader.className = 'node-loading';
          var spinner = document.createElement('div');
          spinner.className = 'spinner';
          var text = document.createElement('span');
          text.className = 'text';
          text.textContent = 'Thinking...';
          loader.appendChild(spinner);
          loader.appendChild(text);
          nodeElement.style.position = 'relative';
          nodeElement.appendChild(loader);
        }
      } else {
        var loader = nodeElement.querySelector('.node-loading');
        if (loader) loader.remove();
      }
    }

    // ============ GRAPH MODIFY MODAL ============
    var graphModifyTargetComponent = null;

    function openGraphModifyModal(componentId) {
      var data = state.componentData[componentId] || { title: componentId };
      graphModifyTargetComponent = componentId;
      document.getElementById('graph-modify-title').textContent = 'AI: Modify Graph around "' + data.title + '"';
      document.getElementById('graph-modify-text').value = '';
      document.getElementById('graph-modify-modal').classList.add('visible');
      document.getElementById('graph-modify-text').focus();
    }

    document.getElementById('graph-modify-cancel').addEventListener('click', function() {
      document.getElementById('graph-modify-modal').classList.remove('visible');
      graphModifyTargetComponent = null;
    });

    document.getElementById('graph-modify-send').addEventListener('click', function() {
      var requestText = document.getElementById('graph-modify-text').value.trim();
      if (requestText && graphModifyTargetComponent && bridgeAvailable) {
        triggerGraphModification(graphModifyTargetComponent, requestText);
      }
      document.getElementById('graph-modify-modal').classList.remove('visible');
      graphModifyTargetComponent = null;
    });

    document.getElementById('graph-modify-modal').addEventListener('click', function(e) {
      if (e.target === document.getElementById('graph-modify-modal')) {
        document.getElementById('graph-modify-modal').classList.remove('visible');
        graphModifyTargetComponent = null;
      }
    });

    function triggerGraphModification(componentId, requestText) {
      if (state.pendingAIRequests[componentId]) {
        console.log('AI request already pending for', componentId);
        return;
      }

      var data = state.componentData[componentId] || { title: componentId };

      // Serialize current graph state
      var currentGraph = {
        components: Object.keys(state.componentData).map(function(id) {
          var c = state.componentData[id];
          return { id: id, title: c.title, description: c.description, file: c.file };
        }),
        workflow: WORKFLOW_STRUCTURE,
        treeStructure: state.treeStructure
      };

      var context = {
        nodeTitle: data.title,
        nodeDescription: data.description || '',
        projectName: PROJECT_NAME,
        currentGraph: currentGraph,
        prompt: requestText + '\n\nReturn a JSON response with modifications object containing: addNodes, removeNodes, updateNodes arrays. Only modify the data, never HTML.'
      };

      state.pendingAIRequests[componentId] = true;
      renderCurrentView();

      window.BridgeClient.sendAndWait('modify-graph', componentId, 'architecture', context).then(function(response) {
        delete state.pendingAIRequests[componentId];

        console.log('Raw response.content length:', response.content ? response.content.length : 0);
        console.log('Raw response.content:', response.content);

        // Try to parse and apply modifications
        try {
          applyGraphModifications(response.content, componentId, requestText);
        } catch (err) {
          console.error('Failed to apply modifications:', err);
          // Store as regular annotation if parsing fails
          if (!state.annotations[componentId]) state.annotations[componentId] = [];
          state.annotations[componentId].unshift({
            type: 'ai',
            action: 'modify-graph',
            text: response.content,
            timestamp: Date.now(),
            collapsed: false
          });
        }

        saveState();
        updateAnnotationsSummary();
        renderCurrentView();
        renderTree();
        if (state.selectedComponent === componentId) {
          updateDetails();
        }
      }).catch(function(err) {
        delete state.pendingAIRequests[componentId];
        console.error('Graph modification failed:', err);
        alert('AI request failed: ' + err.message);
        renderCurrentView();
      });
    }

    function applyGraphModifications(content, componentId, originalRequest) {
      // Try to extract JSON from the response
      var modifications;

      // Find ```json and then find the LAST ``` to handle nested code blocks in content
      var jsonStartMatch = content.match(/```json\s*/);
      if (jsonStartMatch) {
        var startIdx = jsonStartMatch.index + jsonStartMatch[0].length;
        // Find the last ``` in the content
        var lastBacktickIdx = content.lastIndexOf('```');
        if (lastBacktickIdx > startIdx) {
          var jsonStr = content.substring(startIdx, lastBacktickIdx).trim();
          console.log('Extracted JSON length:', jsonStr.length);
          try {
            var parsed = JSON.parse(jsonStr);
            modifications = parsed.modifications || parsed;
          } catch (parseErr) {
            console.error('JSON parse error:', parseErr.message);
            console.error('JSON string (first 500):', jsonStr.substring(0, 500));
            console.error('JSON string (last 500):', jsonStr.substring(jsonStr.length - 500));
            throw parseErr;
          }
        } else {
          throw new Error('No closing ``` found for JSON block');
        }
      } else {
        // Try to find raw JSON without markdown code block
        var rawMatch = content.match(/\{[\s\S]*"(modifications|addNodes|removeNodes|updateNodes)"[\s\S]*\}/);
        if (rawMatch) {
          var parsed = JSON.parse(rawMatch[0]);
          modifications = parsed.modifications || parsed;
        } else {
          throw new Error('No valid modifications JSON found in response');
        }
      }

      var changeCount = 0;

      // Helper to find parent node in workflow for positioning new nodes
      function findParentInWorkflow(parentId) {
        if (!state.workflowStructure || !state.workflowStructure.nodes) return null;
        return state.workflowStructure.nodes.find(function(n) { return n.id === parentId; });
      }

      // Remove nodes/components
      if (modifications.removeNodes && Array.isArray(modifications.removeNodes)) {
        modifications.removeNodes.forEach(function(nodeId) {
          if (state.componentData[nodeId]) {
            delete state.componentData[nodeId];
            // Remove from tree structure
            state.treeStructure.forEach(function(section) {
              section.items = section.items.filter(function(item) { return item.id !== nodeId; });
            });
            // Remove from workflow structure
            if (state.workflowStructure && state.workflowStructure.nodes) {
              state.workflowStructure.nodes = state.workflowStructure.nodes.filter(function(n) { return n.id !== nodeId; });
            }
            if (state.workflowStructure && state.workflowStructure.edges) {
              state.workflowStructure.edges = state.workflowStructure.edges.filter(function(e) { return e.from !== nodeId && e.to !== nodeId; });
            }
            changeCount++;
          }
        });
      }

      // Update nodes/components
      if (modifications.updateNodes && Array.isArray(modifications.updateNodes)) {
        modifications.updateNodes.forEach(function(update) {
          console.log('Trying to update node:', update.id, 'exists in componentData:', !!state.componentData[update.id]);
          if (state.componentData[update.id]) {
            var comp = state.componentData[update.id];
            // Support both formats: update.changes.X and update.X, plus name/desc aliases
            var changes = update.changes || update;
            if (changes.title || changes.name) comp.title = changes.title || changes.name;
            if (changes.description || changes.desc) comp.description = changes.description || changes.desc;
            if (changes.file) comp.file = changes.file;
            // Also update workflow node label if exists
            if (state.workflowStructure && state.workflowStructure.nodes) {
              var wfNode = state.workflowStructure.nodes.find(function(n) { return n.id === update.id; });
              console.log('Workflow node found:', !!wfNode, 'for id:', update.id);
              if (wfNode && (changes.title || changes.name)) {
                wfNode.label = changes.title || changes.name;
              }
            }
            changeCount++;
          }
        });
      }

      // Add nodes/components - support both title/description and name/desc formats
      if (modifications.addNodes && Array.isArray(modifications.addNodes)) {
        var parentNode = findParentInWorkflow(componentId);
        var parentLayer = parentNode ? parentNode.layer : 0;
        var addedCount = 0;

        modifications.addNodes.forEach(function(node) {
          var nodeTitle = node.title || node.name;
          var nodeDesc = node.description || node.desc || '';
          if (!node.id || !nodeTitle) return;
          if (state.componentData[node.id]) return; // Skip duplicates

          state.componentData[node.id] = {
            title: nodeTitle,
            description: nodeDesc,
            file: node.file || ''
          };

          // Add to tree structure (first section or create new one)
          if (state.treeStructure.length > 0) {
            state.treeStructure[0].items.push({
              id: node.id,
              icon: node.isIdea ? 'ðŸ’¡' : 'ðŸ“¦',
              iconClass: node.isIdea ? 'idea' : 'component'
            });
          }

          // Add to workflow structure for visual display
          if (state.workflowStructure) {
            if (!state.workflowStructure.nodes) state.workflowStructure.nodes = [];
            // Inherit phase from parent node for consistent styling
            var parentWfNode = findParentInWorkflow(componentId);
            var nodePhase = parentWfNode ? parentWfNode.phase : 'phase-1';
            state.workflowStructure.nodes.push({
              id: node.id,
              componentId: node.id,
              label: nodeTitle,
              type: 'process',
              phase: nodePhase
            });

            // Automatically create edge from parent (componentId) to new node
            // This ensures new nodes appear as children of the selected node
            if (!state.workflowStructure.edges) state.workflowStructure.edges = [];
            var edgeExists = state.workflowStructure.edges.some(function(e) {
              return e.from === componentId && e.to === node.id;
            });
            if (!edgeExists) {
              state.workflowStructure.edges.push({
                from: componentId,
                to: node.id,
                label: ''
              });
            }

            addedCount++;
          }

          // Add to data flow layers - find the layer containing the parent and add there
          if (state.dataFlowLayers && state.dataFlowLayers.length > 0) {
            var parentLayerIdx = -1;
            for (var i = 0; i < state.dataFlowLayers.length; i++) {
              if (state.dataFlowLayers[i].items && state.dataFlowLayers[i].items.indexOf(componentId) !== -1) {
                parentLayerIdx = i;
                break;
              }
            }
            if (parentLayerIdx !== -1) {
              state.dataFlowLayers[parentLayerIdx].items.push(node.id);
            }
          }

          changeCount++;
        });
      }

      // Add edges to workflow
      if (modifications.addEdges && Array.isArray(modifications.addEdges)) {
        modifications.addEdges.forEach(function(edge) {
          if (state.workflowStructure) {
            if (!state.workflowStructure.edges) state.workflowStructure.edges = [];
            // Check if edge already exists
            var exists = state.workflowStructure.edges.some(function(e) {
              return e.from === edge.from && e.to === edge.to;
            });
            if (!exists) {
              state.workflowStructure.edges.push({
                from: edge.from,
                to: edge.to,
                label: edge.label || ''
              });
              changeCount++;
            }
          }
        });
      }

      // Remove edges from workflow
      if (modifications.removeEdges && Array.isArray(modifications.removeEdges)) {
        modifications.removeEdges.forEach(function(edge) {
          if (state.workflowStructure && state.workflowStructure.edges) {
            var idx = state.workflowStructure.edges.findIndex(function(e) {
              return e.from === edge.from && e.to === edge.to;
            });
            if (idx !== -1) {
              state.workflowStructure.edges.splice(idx, 1);
              changeCount++;
            }
          }
        });
      }

      // Store modification record as annotation
      if (!state.annotations[componentId]) state.annotations[componentId] = [];
      state.annotations[componentId].unshift({
        type: 'ai',
        action: 'modify-graph',
        text: 'Graph modified: ' + changeCount + ' changes applied.\n\nRequest: ' + originalRequest + '\n\n' + (modifications.explanation || ''),
        timestamp: Date.now(),
        collapsed: false
      });

      console.log('Applied', changeCount, 'graph modifications');
    }
    // ============ END GRAPH MODIFY MODAL ============
    // ============ END AI BRIDGE INTEGRATION ============

    var wasLoaded = loadState();
    zoom.load(); // Load saved zoom level

    // Initialize bridge client
    initBridgeClient();

    // Set header title from config
    document.getElementById('header-title').textContent = PROJECT_NAME + ' - Architecture Explorer';
    document.title = PROJECT_NAME + ' - Architecture Explorer';

    renderTree();
    renderCurrentView();
    updateAnnotationsSummary();
    updateDetails();
    if (wasLoaded) console.log('Restored saved state from localStorage');
    })(); // End init
  </script>
</body>
</html>
